# -*- coding: utf-8 -*-
"""
/***************************************************************************
 NADMaps
                                 A QGIS plugin
 Centrale plek om handige kaarten voor waterketen en rioolbeheer te vinden en snel in te laden.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-01-09
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Netwerk Waterketen Delfland
        email                : dataplatform@waterketendelfland.nl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# General packages
import os.path
import json
import re
import hashlib
import urllib.request, urllib.parse, urllib.error

# PyQGIS packages
from qgis.PyQt.QtCore import (
    Qt, QSettings,
    QTranslator,
    QCoreApplication,
    QSortFilterProxyModel,
    QRegularExpression,
    QTimer,
    QSize
)
from qgis.PyQt.QtGui import QIcon, QStandardItemModel, QStandardItem, QColor
# from qgis.PyQt import QtWidgets
from qgis.gui import QgsVertexMarker
# from qgis.PyQt import QtCore, QtGui, 
# https://api.qgis.org/api/group__core.html
from qgis.core import (
    Qgis,
    QgsProject,
    QgsLayerTreeLayer,
    QgsRasterLayer,
    QgsMessageLog,
    QgsVectorLayer,
    QgsVectorTileLayer,
    QgsCoordinateReferenceSystem,
    QgsRectangle,
    QgsCoordinateTransform,
    QgsGeometry,
    QgsWkbTypes,
    QgsPointXY,
    QgsMapLayer,
)
from qgis.PyQt.QtWidgets import (
    QSizePolicy,
    QAction,
    QAbstractItemView,
    QPushButton,
    QDialog,
    QGridLayout,
    QDialogButtonBox,
    QCompleter,
    QSlider,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QLayout,
    QLabel,
    QStackedWidget
)

# Initialize Qt resources from file resources.py
from .resources import *
# Import code for the search and zoom function
from .lib.locatieserver import (
    suggest_query,
    TypeFilter,
    LsType,
    lookup_object,
    get_lookup_object_url,
    Projection,
)

from .lib.load_layers import LoadLayers, load_thema_layer
# Import the code for the dialog
from .nad_maps_dialog import NADMapsDialog
from .nad_maps_popup import NADMapsPopup
from .lib.constants import PLUGIN_NAME, PLUGIN_ID



#########################################################################################
####################  Run main script to initiate when NAD button is pressed ############
#########################################################################################


class NADMaps(object):
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        self.dlg = NADMapsDialog(parent=self.iface.mainWindow())
        self.popup = NADMapsPopup(parent=self.iface.mainWindow())
        self.dlg.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Maximum)
        # initialize locale (find language of the user)
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'NADMaps_{}.qm'.format(locale))

        self.creator = "Gebruiker" # name of creator (eg. user or plugin) of themas. Base themas cannot be deleted by users
        thema_filename = "thema.json"
        self.thema_path = os.path.join(
            self.plugin_dir,
            "resources\\themas",
            thema_filename)

        styling_filename = "styling.json"
        self.styling_path = os.path.join(
            self.plugin_dir,
            "resources\\styling",
            styling_filename)
        
        self.styling_files_path = os.path.join(
            self.plugin_dir,
            "resources\\styling\\qml_files")

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&NAD Waterketen Kaarten')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        # will be set True in run()
        self.setup_completed = False
        self.current_layer = None

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        self.run_icon = QIcon(
            os.path.join(self.plugin_dir, "resources", "nad.png")
        )
        self.filled_star = QIcon(
            os.path.join(self.plugin_dir, "resources", "filled-star-50.png")
        )
        self.outlined_star = QIcon(
            os.path.join(self.plugin_dir, "resources", "outlined-star-50.png")
        )

        self.add_action(
            icon_path = self.run_icon,
            text=PLUGIN_NAME,
            callback=self.run,
            parent=self.iface.mainWindow())

        # Set default layer loading behaviour
        self.service_type_mapping = {
            "wms": "WMS",
            "wmts": "WMTS",
            "wfs": "WFS",
            "wcs": "WCS",
            "api features": "OGC API - Features",
            "api tiles": "OGC API - Tiles",
        }

        self.layer_type_mapping = {
            0: "VectorLayer",
            1: "RasterLayer",
            2: "PluginLayer",
            3: "MeshLayer",
            4: "VectorTileLayer",
            5: "AnnotationLayer",
            6: "PointCloudLayer",
            7: "GroupLayer"
        }


#########################################################################################
####################  Run main script to initiate when NAD button is pressed ############
#########################################################################################

    def run(self, hiddenDialog=False):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.setup_completed == False:
            self.setup_completed = True
            # setup the (proxy)models
            self.setup_models()
            self.log('Start logging')
            self.setup_interactions()
            
            # create an initial list of active layers
            self.update_active_layers_list()
            
            # create a list of existing themas
            self.update_thema_list()

            # Create a list of all layers available via the plugin
            self.layers_nad = []
            layer_path = os.path.join(self.plugin_dir, "resources", "layers-nad.json")
            with open(layer_path, "r", encoding="utf-8") as f:
                self.layers_nad.extend(json.load(f))

            for layer in self.layers_nad:
                if isinstance(layer["name"], str):
                    self.add_source_row(layer)


            # Format the list views that are not formatted in their function
            self.logModel.setHeaderData(0, Qt.Orientation.Horizontal, "Log bericht")
            self.logModel.horizontalHeaderItem(0).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
            self.dlg.logView.horizontalHeader().setStretchLastSection(True)

            self.dlg.mapListView.verticalHeader().setSectionsClickable(False)
            self.dlg.mapListView.horizontalHeader().setSectionsClickable(False)
            # hide itemFilter column:
            self.dlg.mapListView.hideColumn(3)
            self.dlg.mapListView.setColumnWidth(
                0, 250
            )  # set name to 300px (there are some huge layernames)
            self.dlg.mapListView.horizontalHeader().setStretchLastSection(True)
            # self.dlg.mapListView.resizeColumnsToContents()

            self.sourceModel.setHeaderData(2, Qt.Orientation.Horizontal, "Service")
            self.sourceModel.setHeaderData(1, Qt.Orientation.Horizontal, "Type")
            self.sourceModel.setHeaderData(0, Qt.Orientation.Horizontal, "Laagnaam")
            self.sourceModel.horizontalHeaderItem(2).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
            self.sourceModel.horizontalHeaderItem(1).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
            self.sourceModel.horizontalHeaderItem(0).setTextAlignment(Qt.AlignmentFlag.AlignLeft)

            # TODO: set projection to ESPG:28992
            projectCrs = QgsCoordinateReferenceSystem.fromEpsgId(28992)
            QgsProject.instance().setCrs(projectCrs)
        
        # set which buttons should be shown
        tab_index = self.dlg.tabWidget.currentIndex()
        self.active_buttons(tab_index)
        # show the dialog
        if not hiddenDialog:
            self.dlg.show()

#########################################################################################
############################  Show and load regular layers ##############################
#########################################################################################

    def add_source_row(self, serviceLayer):
        # you can attache different "data's" to to an QStandarditem
        # default one is the visible one:
        stype = (
            self.service_type_mapping[serviceLayer["service_type"]]
            if serviceLayer["service_type"] in self.service_type_mapping
            else serviceLayer["service_type"].upper()
        )
        itemType = QStandardItem(str(stype))
        # userrole is a free form one:
        # only attach the data to the first item
        # service layer = a dict/object with all props of the layer
        # https://www.riverbankcomputing.com/static/Docs/PyQt4/qt.html#ItemDataRole-enum
        # tooltip = "Dubbelklik om een kaartlaag in te laden"
        tooltip = serviceLayer["service_abstract"]
        itemType.setToolTip(self.tr(tooltip))
        # only wms services have styles (sometimes)
        layername = serviceLayer["title"]
        styles_string = ""
        if "styles" in serviceLayer:
            styles_string = " ".join(
                [" ".join(x.values()) for x in serviceLayer["styles"]]
            )

        itemLayername = QStandardItem(str(serviceLayer["title"]))
        itemLayername.setData(serviceLayer, Qt.ItemDataRole.UserRole)
        itemLayername.setToolTip(tooltip)
        # itemFilter is the item used to search filter in. That is why layername is a combi of layername + filter here
        itemFilter = QStandardItem(
            f'{serviceLayer["service_type"]} {layername} {serviceLayer["service_title"]} {serviceLayer["service_abstract"]} {styles_string}'
        )
        itemServicetitle = QStandardItem(str(serviceLayer["service_title"]))
        itemServicetitle.setToolTip(tooltip)
        self.sourceModel.appendRow(
            [itemLayername, itemType, itemServicetitle, itemFilter]
        )

    def get_current_layer(self, selectedIndexes):
        # self.log(f"get_current_layer: len(selectedIndexes) is {str(len(selectedIndexes))}")
        if len(selectedIndexes) == 0:
            self.current_layer = None
            return

        self.dlg.mapListView.scrollTo(self.dlg.mapListView.selectedIndexes()[0])
        # itemType holds the data (== column 1) hence self.dlg.mapListView.selectedIndexes()[1], see itemType.setData(serviceLayer, Qt.ItemDataRole.UserRole)
        self.current_layer = self.dlg.mapListView.selectedIndexes()[0].data(
            Qt.ItemDataRole.UserRole
        )

    def load_layer(self, tree_location):
        load = LoadLayers(self.iface, self.current_layer, tree_location)
        load.load_layer()


#########################################################################################
##############  Manage thema sets (a list of one or more map layers) ####################
#########################################################################################

    def delete_thema(self):
        """Delete an existing thema (only user defined themas should be deleted)"""
        # self.log("Starting the delete_thema function")

        # Find the thema name to be deleted
        thema_name = self.current_thema["thema_name"]
        # self.log(f"Thema to be deleted is {thema_name}")

        with open(self.thema_path, "r", encoding="utf-8") as f:
            jsondata = json.load(f)

        # Iterate through the json list and remove the object with the selected name
        jsondata = [obj for obj in jsondata if obj["thema_name"] != thema_name]
        
        with open(self.thema_path, "w", encoding="utf-8") as feedsjson:
            json.dump(jsondata, feedsjson, indent='\t')

        self.update_thema_list()
        # self.log("Finished the delete_thema function")

    def save_thema(self, all: bool):
        """
        Save a collection of layers in order to later quickly load them
        """
        # self.log(f"Save thema function: save all? {all}")
        
        # Collect a json string with a thema_name and a list of layer names
        thema_name = self.dlg.saveThemaLineEdit.text()
        # self.log(f"Thema name given is {thema_name}")

        string = "{\"thema_name\": \"" + thema_name + "\", "
        string = f"{string}\"creator\": \"{self.creator}\"," # creator
        string = string + "\"layers\": [{"

        # https://doc.qt.io/qt-6/qabstractitemmodel.html#details # documentation p1
        # https://doc.qt.io/qt-6/qt.html#ItemDataRole-enum # documentation p2
        if all == False:
            selected_layers = self.selected_active_layers
        else:
            selected_layers = QgsProject.instance().mapLayers().values()
            # selected_layers = set(index.siblingAtColumn(0) for index in selectedIndexes)

        # self.log(f"List of active selected layers is {selected_layers}, with length is {len(selected_layers)}")
        for i, layer in enumerate(selected_layers):
            layer_type = self.layer_type_mapping[layer.type()]
            styling = layer.customProperty( 'layerStyle', '' )
            # self.log(f"Info of layer {layer.name()}, styling is {layer.customProperty( "layerStyle", "" )}, provider_type: {layer.providerType()}, layer_type: {layer_type}, source: {layer.source()}")
            string = f"{string}\"name\": \"{layer.name()}\"," # layer name
            string = f"{string}\"source\": \"{layer.source()}\"," # source
            string = f"{string}\"styling\": \"{styling}\"," # styling
            string = f"{string}\"provider_type\": \"{layer.providerType()}\"," # provider_type
            string = f"{string}\"layer_type\": \"{layer_type}\"" # service_type
            # string = string + "\"styling\": \"" + layer.styling() + "\"," # styling
            if i == len(selected_layers) - 1:
                string = string + "}]"
            else:
                string = string + "}, {"
        string = string + "}"

        data = json.loads(string)
        # https://stackoverflow.com/questions/12994442/how-to-append-data-to-a-json-file
        try:
            with open(self.thema_path, "r", encoding="utf-8") as feedsjson:
                feeds = json.load(feedsjson)
        except:
            feeds = []
        
        with open(self.thema_path, "w", encoding="utf-8") as feedsjson:
            feeds.append(data)
            json.dump(feeds, feedsjson, indent='\t')
        
        self.update_thema_list()
        self.dlg.saveThemaLineEdit.clear()

    def update_thema_list(self):
        """Add a thema to the thema model"""
        self.themaModel.clear()
        
        themas = []
        try:
            with open(self.thema_path, "r", encoding="utf-8") as f:
                themas.extend(json.load(f))
        except:
            return

        # self.log(f"themas: {themas}")
        plugin_thema_check = self.dlg.pluginThemaCheckBox.isChecked()
        user_thema_check = self.dlg.userThemaCheckBox.isChecked()
        fav_thema_check = self.dlg.favoriteThemaCheckBox.isChecked()
        # self.log(f"Filters checked: plugin = {plugin_thema_check}, user = {user_thema_check}, favorite = {fav_thema_check}")
        themas_exist = False
        for thema in themas:
            if (plugin_thema_check and thema["creator"] == "Plugin") or (user_thema_check and thema["creator"] == "Gebruiker"):
                # if fav_thema_check == False or thema["favorite"] != "":
                if fav_thema_check == False:
                    itemThema = QStandardItem(str(thema["thema_name"]))
                    # itemFavorite = self.update_favorite(thema)
                    itemFavorite = QStandardItem()
                    itemFavorite.setCheckable(True)
                    itemSource = QStandardItem(str(thema["creator"]))
                    itemFilter = QStandardItem(f'{thema["thema_name"]} {thema["layers"]}')
                    # https://doc.qt.io/qt-6/qstandarditem.html#setData
                    itemThema.setData(thema, Qt.ItemDataRole.UserRole)
                    self.themaModel.appendRow(
                        [itemThema, itemFavorite, itemSource, itemFilter]
                    )
                    themas_exist = True
        
        # if no thema is leftover after selection, then present an empty row
        if not themas_exist:
            itemThema = QStandardItem(str(""))
            itemSource = QStandardItem(str(""))
            itemFilter = QStandardItem(str(""))
            self.themaModel.appendRow(
                [itemThema, itemSource, itemFilter]
            )

        self.themaModel.setHeaderData(2, Qt.Orientation.Horizontal, "Bron")
        self.themaModel.setHeaderData(1, Qt.Orientation.Horizontal, "Favoriet")
        self.themaModel.setHeaderData(0, Qt.Orientation.Horizontal, "Thema")
        self.themaModel.horizontalHeaderItem(2).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.themaModel.horizontalHeaderItem(1).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.themaModel.horizontalHeaderItem(0).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.dlg.themaView.horizontalHeader().setStretchLastSection(True)
        self.dlg.themaView.hideColumn(3)
        self.dlg.themaView.setColumnWidth(
            0, 300
        )  # set name to 300px (there are some huge layernames)
        self.dlg.themaView.horizontalHeader().setStretchLastSection(True)
        self.dlg.themaView.sortByColumn(0, QtCore.Qt.AscendingOrder)



#########################################################################################
############  Update and load list of layers that are part of a thema set ###############
#########################################################################################

    def show_thema_layers(self, selectedIndexes):
        """Show the layers that are part of a thema"""
        # # self.log(f"show_thema_layers: len(selectedIndexes) is {str(len(selectedIndexes))}")
        if len(selectedIndexes) == 0:
            self.current_layer = None
            return
        
        self.current_thema = self.dlg.themaView.selectedIndexes()[0].data(
            Qt.ItemDataRole.UserRole
        )
        if not self.current_thema == None:
            self.thema_layers = self.current_thema["layers"]
            self.update_thema_layers()

    def load_thema_layers(self):
        """Load the layers of this thema to the canvas"""
        # # self.log(f"load_thema_layers: current_thema is {self.current_thema["thema_name"]}")
        thema_layers = self.thema_layers
        # create a group to load into to
        root = QgsProject.instance().layerTreeRoot()
        group_name = self.current_thema["thema_name"]
        group = root.insertGroup(0, group_name)
        # https://gis.stackexchange.com/questions/397789/sorting-layers-by-name-in-one-specific-group-of-qgis-layer-tree
        for layer in thema_layers:
            name = layer["name"]
            layer_type = layer["layer_type"]
            uri = layer["source"]
            provider_type = layer["provider_type"]
            style = layer["styling"]
            # title, layer_type, provider_type, uri
            # self.log(name)
            self.current_layer = layer
            result = load_thema_layer(name, uri, layer_type, provider_type)
            # # self.log(f"Loading thema layer {layer}")
            QgsProject.instance().addMapLayer(result, False) # If True (by default), the layer will be added to the legend and to the main canvas
            group.addLayer(result) # Add the layer to the group
            # check if styling is saved in .resources.styling styling.json
            # if so, then apply that style, else apply no style

            if not style == "":
                style_code = self.style_code(style, uri)
                path = f"{self.styling_files_path}/{style_code}.qml"
                result.loadNamedStyle(path)
                result.triggerRepaint()
                result.setCustomProperty( "layerStyle", style )

        # self.iface.layerTreeView().collapseAllNodes()
        # self.update_active_layers_list()

    def update_thema_layers(self):
        """Update the list of layers contained with this thema"""
        thema_layers = self.thema_layers
        
        self.themaMapModel.clear()

        # self.log(f"Number of layers: {len(thema_layers)}")
        if len(thema_layers) < 1:
            itemLayername = QStandardItem(str(""))
            itemProvider = QStandardItem(str(""))
            itemSource = QStandardItem(str(""))
            self.themaMapModel.appendRow(
                [itemLayername, itemProvider, itemSource]
            )
        else:
            for layer in thema_layers:
                itemLayername = QStandardItem(str(layer["name"]))
                stype = (
                    self.service_type_mapping[layer["provider_type"]]
                    if layer["provider_type"] in self.service_type_mapping
                    else layer["provider_type"].upper()
                )
                itemProvider = QStandardItem(str(stype))
                itemStyle = QStandardItem(str(layer["styling"]))
                # itemStyle = QStandardItem(str("styling"))
                itemSource = QStandardItem(str(layer["source"]))
                self.themaMapModel.appendRow(
                    [itemLayername, itemProvider, itemStyle, itemSource]
                )
        
        self.themaMapModel.setHeaderData(3, Qt.Orientation.Horizontal, "Bron")
        self.themaMapModel.setHeaderData(2, Qt.Orientation.Horizontal, "Style")
        self.themaMapModel.setHeaderData(1, Qt.Orientation.Horizontal, "Type")
        self.themaMapModel.setHeaderData(0, Qt.Orientation.Horizontal, "Laagnaam")
        self.themaMapModel.horizontalHeaderItem(3).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.themaMapModel.horizontalHeaderItem(2).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.themaMapModel.horizontalHeaderItem(1).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.themaMapModel.horizontalHeaderItem(0).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.dlg.themaMapListView.horizontalHeader().setStretchLastSection(True)
        # self.dlg.themaMapListView.hideColumn(3)
        
        self.dlg.themaMapListView.setColumnWidth(
            0, 200
        )  # set name to 300px (there are some huge layernames)
        self.dlg.themaMapListView.horizontalHeader().setStretchLastSection(True)


#########################################################################################
#########################  Show and load styling for layers #############################
#########################################################################################

    def style_code(self, style_name: str, source: str):
        """
        Create the name for a styling file. Encoded with md5 for better readability.

        :param style_name: Name given by a user to a styling.
        :type style_name: str

        :param source: Uri path to the layer source.
        :type source: str
        """
        md = hashlib.md5(str(source).encode("utf"))
        text = md.hexdigest()
        return str(style_name.lower() + '_' + text) 

    def load_styling(self):
        style_name = self.dlg.stylingComboBox.currentText()
        layer = self.dlg.stylingComboBox.currentData()
        style_code = self.style_code(style_name, layer.source())

        if not layer == None:
            path = f"{self.styling_files_path}/{style_code}.qml"
            layer.loadNamedStyle(path)
            layer.triggerRepaint()
            layer.setCustomProperty( "layerStyle", style_name )
            self.update_active_layers_list()

        # vlayer.renderer().symbol().setSize(6)
        # vlayer.triggerRepaint()
        # https://gis.stackexchange.com/search?q=%5Bqml%5Dsave
        # very old blog: https://snorfalorpagus.net/blog/2014/03/04/symbology-of-vector-layers-in-qgis-python-plugins/
        # https://anitagraser.com/pyqgis-101-introduction-to-qgis-python-programming-for-non-programmers/pyqgis-101-styling-vector-layers/
        # https://opensourceoptions.com/loading-and-symbolizing-raster-layers/

    def delete_styling(self):
        """Delete an existing style (only user defined styles should be deleted)"""
        # self.log("Starting the delete_styling function")

        # Find the style name to be deleted
        style_name = self.dlg.stylingComboBox.currentText()
        data = self.dlg.stylingComboBox.currentData()
        # self.log(f"Style to be deleted is {style_name}")
        # self.log(f"Style data is {data}")
        if not data == None:
            source = data.source()
            style_code = self.style_code(style_name, source)
            # self.log(f"Style code is {style_code}")
            # self.log(f"data.source() is {source}")

            try:
                with open(self.styling_path, "r", encoding="utf-8") as f:
                    jsondata = json.load(f)
            except Exception as e:
                self.log(f"Error with message: {e}")

            new_jsondata = []
            for layer in jsondata:
                if layer["source"] == source:
                    current_layer = layer
                else:
                    new_jsondata.append(layer)
            
            existing_styles = current_layer["styles"]
            # if there are other style options, then we want to preserve those
            if len(existing_styles) > 1:
                styles = [obj for obj in existing_styles if obj["file"] != style_code]
                new_data = {}
                new_data["layer_name"] = current_layer["layer_name"]
                new_data["source"] = current_layer["source"]
                new_data["styles"] = styles
            
                new_jsondata.append(new_data)

            try:
                with open(self.styling_path, "w", encoding="utf-8") as f:
                    json.dump(new_jsondata, f, indent='\t')
            except Exception as e:
                self.log(f"Error with message: {e}")
            file_path = f"{self.styling_files_path}\\{style_code}.qml"
            if os.path.exists(file_path):
                os.remove(file_path)

            self.update_styling_list()

    def style_overwrite(self, show_popup: bool):
        """
        Save the styling of the current layer to a qml file

        :param show_popup: Show or close the popup asking about overwriting an existing style. Also disables the main dialogue window.
        :type show_popup: bool
        """
        if show_popup:
            self.popup.show()
            self.dlg.setEnabled(False)
        else:
            self.popup.hide()
            self.dlg.setEnabled(True)

    def check_existing_style(self):
        """Check if a style already exists for this layer with the same name"""
        selectedIndexes = self.dlg.activeMapListView.selectedIndexes()
        nr_of_selected_rows = len(set(index.row() for index in selectedIndexes))
        # self.log(f"get_active_layer: nr of rows selected is {nr_of_selected_rows}")

        # enable or disable the styling-functions
        if nr_of_selected_rows == 1:
            # first_index_list = set(index.siblingAtColumn(0) for index in selectedIndexes)
            self.layer_to_style = self.dlg.activeMapListView.selectedIndexes()[0].data(
                Qt.ItemDataRole.UserRole
            )
            style_name = self.dlg.saveStylingLineEdit.text()
            if not style_name == "":
                source = self.layer_to_style.source()
                style_code = self.style_code(style_name, source)
                # self.log(f"style_code = {style_code}")

                try:
                    with open(self.styling_path, "r", encoding="utf-8") as feedsjson:
                        feeds = json.load(feedsjson)
                except:
                    return

                existing_styles = []
                for feed in feeds:
                    if feed["source"] == source:
                        existing_styles = feed["styles"]

                # Check if a style with the same name exists
                check_overwrite = False
                for i, style in enumerate(existing_styles):
                    if style["file"] == style_code:
                        check_overwrite = True
                
                if check_overwrite == False:
                    self.save_styling()
                else:
                    # popup
                    self.style_overwrite(True)

    def save_styling(self):
        """
        Save the styling of the current layer to a qml file
        """
        # use the layer["source"] (uri) as the id to match styling options (the rest can be changed easily).
        # TODO: what about services where you define the styling when you send the request? remove and reload?
        layer = self.layer_to_style
        # self.log(f"name of selected layer is {layer.name()}, source is {layer.source()}")
        style_name = self.dlg.saveStylingLineEdit.text()
        self.dlg.saveStylingLineEdit.clear()
        source = layer.source()
        layer_name = layer.name()
        style_code = self.style_code(style_name, source)
        # self.log(f"style_code = {style_code}")
        path = f"{self.styling_files_path}\\{style_code}.qml"

        if layer.type() == QgsMapLayer.VectorLayer:
            layer.saveNamedStyle(path)
        else:
            return
        # layer is the data in the layer
        creator = "plugin"

        try:
            with open(self.styling_path, "r", encoding="utf-8") as feedsjson:
                feeds = json.load(feedsjson)
        except:
            feeds = []

        existing_data = []
        existing_styles = []
        for feed in feeds:
            if feed["source"] == source:
                existing_styles = feed["styles"]
            else:
                existing_data.append(feed)

        # Remove the old style information
        for i, style in enumerate(existing_styles):
            if style["file"] == style_code:
                existing_styles.pop(i)

        # add the new style to the list of styles
        style_string = "{" + f"\"name\": \"{style_name}\"," # style name
        style_string = f"{style_string}\"file\": \"{style_code}\"," # source
        style_string = f"{style_string}\"creator\": \"{creator}\"" + "}" # creator (base plugin style or user defined)
        new_style = json.loads(style_string)
        existing_styles.append(new_style)
        existing_styles = str(existing_styles).replace('\'', '\"')

        # create the layer info and add the list of styles
        string = "{\"layer_name\": \"" + layer_name + "\", "
        string = string + "\"source\": \"" + source + "\", "
        string = string + "\"styles\": "
        string = string + str(existing_styles)
        string = string + "}"

        new_data = json.loads(string)
        existing_data.append(new_data)
            
        with open(self.styling_path, "w", encoding="utf-8") as feedsjson:
            json.dump(existing_data, feedsjson, indent='\t')
        layer.setCustomProperty( "layerStyle", style_name )
        self.update_active_layers_list()
        self.update_styling_list()
        # TODO: reselect layer (selectedIndexes = self.dlg.activeMapListView.selectedIndexes())

    def update_styling_list(self):
        """Update the dropdown menu with saved styling options"""
        self.dlg.stylingComboBox.clear()
        selectedIndexes = self.dlg.activeMapListView.selectedIndexes()
        nr_of_selected_rows = len(set(index.row() for index in selectedIndexes))
        # self.log(f"get_active_layer: nr of rows selected is {nr_of_selected_rows}")

        # enable or disable the styling-functions
        if nr_of_selected_rows == 1:
            # first_index_list = set(index.siblingAtColumn(0) for index in selectedIndexes)
            data = self.dlg.activeMapListView.selectedIndexes()[0].data(
                Qt.ItemDataRole.UserRole
            )
            # self.log(f"Data of this layer is {data.source()}")
            layer_style_list = []
            path = self.styling_path
            try:
                with open(path, "r", encoding="utf-8") as f:
                    layer_style_list.extend(json.load(f))
            except:
                # self.log("Failed")
                return

            for layer in layer_style_list:
                if data.source() == layer["source"]:
                    styles = layer["styles"]
                    for style in styles:
                        name = style["name"]
                        self.dlg.stylingComboBox.addItem(name, data)

            # self.dlg.comboSelectProj.setCurrentIndex(1)

#########################################################################################
######################  Show current loaded layers on the canvas ########################
#########################################################################################

    # order = []
    # model = self.iface.layerTreeView().layerTreeModel()
    # root = QgsProject.instance().layerTreeRoot()
    # node = root.findLayer(layer.id())
    # index = model.node2index( node )
    # order.append(index.row())
    # # self.log(order)
    # # sorted_layers = list(selected_layers)
    # # # self.log(f"Sorted layers is {sorted_layers}")

    # bridge = iface.layerTreeCanvasBridge() 
    # order = bridge.customLayerOrder()

    def update_active_layers_list(self):
        """Update the table with active layers in the project"""
        # self.log(f"update_active_layers_list function started")
        self.mapsModel.clear()

        root = QgsProject.instance().layerTreeRoot()
        layers = root.children()
        # self.iface.layerTreeView()
        # layers = QgsProject.instance().mapLayers().values()
        # model = self.iface.layerTreeView().layerTreeModel()
        # root = QgsProject.instance().layerTreeRoot()
        # treeview = self.iface.layerTreeView()
        # self.log(f"treeview is {treeview}")
        
        # layers = self.iface.layerTreeCanvasBridge().mapCanvas().layers()

        # bridge = self.iface.layerTreeCanvasBridge()
        self.log(f"layers is {layers}")
        self.log(f"length is {len(layers)}")

        if len(layers) < 1:
            itemLayername = QStandardItem(str(""))
            itemType = QStandardItem(str(""))
            itemStylingTitle = QStandardItem(str(""))
            itemSource = QStandardItem(str(""))
            itemOrder = QStandardItem(str(""))
            self.mapsModel.appendRow(
                [itemLayername, itemType, itemStylingTitle, itemSource, itemOrder]
            )
        else:
            # QgsProject.instance().mapLayersByName("countries")[0]
            # d = self.iface.openLayoutDesigners()[0]
            # l = d.layout()
            # legend = l.selectedItems()[0]
            # m = legend.model()
            # # self.log(m.rowCount())
            for i, layer in enumerate(layers):
                # index = model.node2index( root.findLayer(layer.id()) )
                # index2 = model.index2legendNode( root.findLayer(layer.id()) )
                # index2 = model.index2legendNode( root.findLayer(layer.id()) )
                # # findLegendNode ; QgsLayerTreeModelLegendNode
                # # QgsLayerTreeModelLegendNode
                # self.log(f"Index is {index.row()} and i is {i}, and index2 is")
                # layer is the same value as QgsVectorLayer(uri, title, "wfs"), e.g. <QgsVectorLayer: 'Riolering WFS: Leiding' (WFS)>
                # self.log(f"Layer {layer} has name: {layer.name()} of type {layer.type()} with source {layer.source()}")
                # https://gis.stackexchange.com/questions/383425/whats-a-provider-in-pyqgis-and-how-many-types-of-providers-exist
                provider_type = layer.providerType()

                itemLayername = QStandardItem(str(layer.name()))
                itemLayername.setData(layer, Qt.ItemDataRole.UserRole)
                stype = (
                    self.service_type_mapping[provider_type]
                    if provider_type in self.service_type_mapping
                    else provider_type.upper()
                )
                itemType = QStandardItem(str(stype))
                # # self.log(f"Styling is {layer.customProperty( "layerStyle", "" )}")
                # styling = "default"
                styling = layer.customProperty( "layerStyle", "" )
                itemStyle = QStandardItem(str(styling))
                itemSource = QStandardItem(str(layer.source()))
                itemSource.setToolTip(str(layer.source()))
                itemOrder = QStandardItem(str(i))
                self.mapsModel.appendRow(
                    [itemLayername, itemType, itemStyle, itemSource, itemOrder]
                )

        self.mapsModel.setHeaderData(4, Qt.Orientation.Horizontal, "Index")
        self.mapsModel.setHeaderData(3, Qt.Orientation.Horizontal, "Bron")
        self.mapsModel.setHeaderData(2, Qt.Orientation.Horizontal, "Style")
        self.mapsModel.setHeaderData(1, Qt.Orientation.Horizontal, "Type")
        self.mapsModel.setHeaderData(0, Qt.Orientation.Horizontal, "Laagnaam")
        self.mapsModel.horizontalHeaderItem(4).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.mapsModel.horizontalHeaderItem(3).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.mapsModel.horizontalHeaderItem(2).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.mapsModel.horizontalHeaderItem(1).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.mapsModel.horizontalHeaderItem(0).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.dlg.activeMapListView.horizontalHeader().setStretchLastSection(True)
        # self.dlg.activeMapListView.hideColumn(3)
        
        self.dlg.activeMapListView.setColumnWidth(
            0, 150
        )  # set name to 300px (there are some huge layernames)
        self.dlg.activeMapListView.horizontalHeader().setStretchLastSection(True)
        self.dlg.activeMapListView.sortByColumn(4, QtCore.Qt.AscendingOrder)

    def get_selected_active_layers(self):
        """
        Get the selected layers from the active layers-tab
        """
        selectedIndexes = self.dlg.activeMapListView.selectedIndexes()
        nr_of_selected_rows = len(set(index.row() for index in selectedIndexes))
        # self.log(f"get_active_layer: nr of rows selected is {nr_of_selected_rows}")

        # enable or disable the styling-functions
        if nr_of_selected_rows == 1:
            self.update_styling_list()
            self.dlg.stylingGroupBox.setEnabled(True)
            self.dlg.stylingGroupBox.setToolTip("")
            self.dlg.saveThemaButton.setEnabled(True)
            self.dlg.saveThemaButton.setToolTip("")
        elif nr_of_selected_rows > 1:
            self.dlg.stylingGroupBox.setEnabled(False)
            self.dlg.stylingGroupBox.setToolTip("Selecteer maar één laag om de styling aan te passen")
            self.dlg.saveThemaButton.setEnabled(True)
            self.dlg.saveThemaButton.setToolTip("")
        elif nr_of_selected_rows == 0:
            self.dlg.stylingGroupBox.setEnabled(False)
            self.dlg.stylingGroupBox.setToolTip("Selecteer maar één laag om de styling aan te passen")
            self.dlg.saveThemaButton.setEnabled(False)
            self.dlg.saveThemaButton.setToolTip("Geen lagen geselecteerd")
            self.selected_active_layers = None
            return

        self.selected_active_layers = []
        first_index_list = set(index.siblingAtColumn(0) for index in selectedIndexes)
        for index in first_index_list:
            # self.log(f"active_layer is {index}, at row {index.row()} and column {index.column()}")
            active_layer = index.data(
                    Qt.ItemDataRole.UserRole
                )
            # # self.log(f"active_layer is {active_layer}")
            # # self.log(f"active_layer name is {active_layer.name()}")
            # # self.log(f"active_layer source is {active_layer.source()}")
            self.selected_active_layers.append(active_layer)


#########################################################################################
####################  Save the current canvas function ############
#########################################################################################

    # TODO: function to export current canvas as pdf or image
    def export_canvas(self):
        """Export the current map to pdf or png, including a north-arrow"""
        # qgis.utils.iface.mapCanvas().saveAsImage('test.png', None, 'PNG') 
        # https://qgis.org/pyqgis/3.40/gui/QgsMapCanvas.html#qgis.gui.QgsMapCanvas


#########################################################################################
####################  Search for locations for the zoom functionality ###################
#########################################################################################

    def zoom_button(self):
        # self.toolbar_search_get_suggestions
        search_text = self.dlg.zoomLineEdit.text()
        result = suggest_query(search_text, self.create_type_filter())[0]["weergavenaam"]
        self.dlg.zoomLineEdit.setText(result)
        suggest_text = self.dlg.zoomLineEdit.text()
        self.on_toolbar_suggest_activated(suggest_text)

    def create_type_filter(self):
        """
        This creates a TypeFilter (Filter Query, see https://github.com/PDOK/locatieserver/wiki/Zoekvoorbeelden-Locatieserver) based on the checkboxes in the dialog. Defaults to []
        """
        
        self.fq_checkboxes = {
            LsType.gemeente,
            LsType.woonplaats,
            LsType.weg,
            LsType.postcode,
            LsType.adres,
            LsType.perceel,
            LsType.hectometerpaal,
            LsType.waterschap,
        }
        filter = TypeFilter([])
        for key in self.fq_checkboxes:
            filter.add_type(key)
        return filter

    def toolbar_search_get_suggestions(self):
        def create_model(_suggestions):
            model = QStandardItemModel()
            for s in _suggestions:
                key = s["weergavenaam"]
                it = QStandardItem(key)
                it.setData(s, Qt.ItemDataRole.UserRole)
                model.appendRow(it)
            return model
        search_text = self.dlg.zoomLineEdit.text()
        if len(search_text) <= 1:
            self.dlg.zoomLineEdit.setCompleter(None)
            return
        results = suggest_query(search_text, self.create_type_filter())
        # https://stackoverflow.com/questions/5129211/qcompleter-custom-completion-rules
        self.completer = QCompleter()
        self.model = create_model(results)
        self.completer.setModel(self.model)
        self.completer.setCompletionMode(QCompleter.CompletionMode.PopupCompletion)
        self.completer.setFilterMode(Qt.MatchFlag.MatchContains)
        self.dlg.zoomLineEdit.setCompleter(self.completer)
        self.dlg.zoomLineEdit.show()
        self.completer.complete()
        self.completer.activated.connect(self.on_toolbar_suggest_activated)
        return

    def on_toolbar_suggest_activated(self, suggest_text):
        items = self.model.findItems(suggest_text)
        if len(items) == 0:  # check should not be necessary
            return
        item = items[0]
        data = item.data(Qt.ItemDataRole.UserRole)
        lookup_id = data["id"]
        self.lookup_toolbar_search_and_zoom(lookup_id)

    def lookup_toolbar_search_and_zoom(self, lookup_id):
        data = None
        try:
            data = lookup_object(lookup_id, Projection.EPSG_28992)
        except Exception as e:
            self.log(f"Failed to lookup an object in the search and zoom function. Error message: {e}")
        if data is None:
            return
        self.zoom_to_result(data)

    def zoom_to_result(self, data):
        # just always transform from 28992 to mapcanvas crs
        crs = self.iface.mapCanvas().mapSettings().destinationCrs()
        crs28992 = QgsCoordinateReferenceSystem.fromEpsgId(28992)
        crsTransform = QgsCoordinateTransform(crs28992, crs, QgsProject.instance())

        adrestekst = "{} - {}".format(data["type"], data["weergavenaam"])
        adrestekst_lower = adrestekst.lower()

        zoom_dict = {
            "adres": 794,
            "perceel": 794,
            "hectometer": 1587,
            "weg": 3175,
            "postcode": 6350,
            "woonplaats": 25398,
            "gemeente": 50797,
            "provincie": 812750,
        }
        z = 1587
        for z_type in zoom_dict.keys():
            if adrestekst_lower.startswith(
                z_type
            ):  # maybe find better way to infer return type?
                z = zoom_dict[z_type]

        geom = QgsGeometry.fromWkt(data["wkt_geom"])
        geom.transform(crsTransform)
        geom_type = geom.type()

        geom_type_dict = {
            QgsWkbTypes.PointGeometry: "point",
            QgsWkbTypes.LineGeometry: "linestring",
            QgsWkbTypes.PolygonGeometry: "polygon",
        }
        if geom_type not in geom_type_dict:
            self.info(
                f"unexpected geomtype return by ls: {geom_type}"
            )  # TODO: better error handling
            return

        geom_bbox = geom.boundingBox()
        rect = QgsRectangle(geom_bbox)
        rect.scale(1.2)
        self.iface.mapCanvas().zoomToFeatureExtent(rect)
        # for point features it is required to zoom to predefined zoomlevel depending on return type
        if re.match(r"^POINT", data["wkt_geom"]):
            self.iface.mapCanvas().zoomScale(z)
        self.iface.mapCanvas().refresh()


#########################################################################################
#################################  Setup functions ######################################
#########################################################################################


    def setup_models(self):
        """
        This does a setup of all the models for list views.
        """
        # Timer on the search bar
        self.timer_toolbar_search = QTimer()
        self.timer_toolbar_search.setSingleShot(True)
        self.timer_toolbar_search.setInterval(200)
        self.timer_toolbar_search.timeout.connect(self.toolbar_search_get_suggestions)
    
        ### Model for the active layer table
        self.mapsModel = QStandardItemModel()
        self.styleFilterMaps = QSortFilterProxyModel()
        self.styleFilterMaps.setSourceModel(self.mapsModel)
        self.styleFilterMaps.setFilterKeyColumn(2)

        self.proxyModelMaps = QSortFilterProxyModel()
        self.proxyModelMaps.setSourceModel(self.styleFilterMaps)
        self.proxyModelMaps.setFilterKeyColumn(1)

        self.dlg.activeMapListView.setModel(self.mapsModel)
        self.dlg.activeMapListView.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
    
        ### Model for the list of thema sets
        self.themaModel = QStandardItemModel()
        self.styleFilterThema = QSortFilterProxyModel()
        self.styleFilterThema.setSourceModel(self.themaModel)
        self.styleFilterThema.setFilterKeyColumn(2)

        self.proxyModelThema = QSortFilterProxyModel()
        self.proxyModelThema.setSourceModel(self.styleFilterThema)
        self.proxyModelThema.setFilterKeyColumn(1) # change this when you want to order by something else (like order in layer panel)

        self.dlg.themaView.setModel(self.proxyModelThema)
        self.dlg.themaView.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
    
        ### Model for the list of layers within a thema set
        self.themaMapModel = QStandardItemModel()
        self.styleFilterThemaMaps = QSortFilterProxyModel()
        self.styleFilterThemaMaps.setSourceModel(self.themaMapModel)
        self.styleFilterThemaMaps.setFilterKeyColumn(4)
        
        self.proxyModelThemaMaps = QSortFilterProxyModel()
        self.proxyModelThemaMaps.setSourceModel(self.styleFilterThemaMaps)
        self.proxyModelThemaMaps.setFilterKeyColumn(3)

        self.dlg.themaMapListView.setModel(self.proxyModelThemaMaps)
        self.dlg.themaMapListView.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)

        # Model for the list of all layers available via the plugin
        self.sourceModel = QStandardItemModel()
        self.styleFilter = QSortFilterProxyModel()
        self.styleFilter.setSourceModel(self.sourceModel)
        self.styleFilter.setFilterKeyColumn(4)

        self.proxyModel = QSortFilterProxyModel()
        self.proxyModel.setSourceModel(self.styleFilter)
        self.proxyModel.setFilterKeyColumn(3)

        self.dlg.mapListView.setModel(self.proxyModel)
        self.dlg.mapListView.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
    
        # Table with logging information
        self.logModel = QStandardItemModel()
        self.dlg.logView.setModel(self.logModel)
        self.dlg.logView.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)

    def setup_interactions(self):
        """
        This does a setup of all the button interactions.
        """
        # Search bars
        self.dlg.searchLineEdit.textChanged.connect(self.filter_layers)
        self.dlg.zoomLineEdit.textEdited.connect(
            lambda: self.timer_toolbar_search.start()
        )
        # Click functions
        self.dlg.zoomButton.clicked.connect(lambda: self.zoom_button())
        self.dlg.loadStyleButton.clicked.connect(lambda: self.load_styling())
        # TODO: make these functions
        self.dlg.removeStyleButton.clicked.connect(lambda: self.delete_styling())
        self.dlg.saveStyleButton.clicked.connect(lambda: self.check_existing_style())

        self.dlg.saveThemaButton.setEnabled(False)
        self.dlg.saveThemaButton.setToolTip("Geen lagen geselecteerd")
        self.dlg.saveThemaButton.clicked.connect(lambda: self.save_thema(False))
        self.dlg.saveAllThemaButton.clicked.connect(lambda: self.save_thema(True))

        self.dlg.pluginThemaCheckBox.clicked.connect(lambda: self.update_thema_list())
        self.dlg.userThemaCheckBox.clicked.connect(lambda: self.update_thema_list())
        self.dlg.favoriteThemaCheckBox.clicked.connect(lambda: self.update_thema_list())
        
        self.dlg.deleteThemaButton.clicked.connect(lambda: self.delete_thema())

        self.dlg.tabWidget.currentChanged.connect(self.active_buttons)
        self.dlg.load_button.clicked.connect(lambda: self.load_button_pressed(False))
        self.dlg.load_close_button.clicked.connect(lambda: self.load_button_pressed(True))
        self.dlg.close_button.clicked.connect(lambda: self.dlg.hide())

        self.dlg.stylingGroupBox.setEnabled(False)

        self.popup.accept_button.clicked.connect(lambda: self.save_styling())
        self.popup.accept_button.clicked.connect(lambda: self.style_overwrite(False))
        self.popup.close_button.clicked.connect(lambda: self.style_overwrite(False))

        # update the information on the current selection of active layers
        self.dlg.activeMapListView.selectionModel().selectionChanged.connect(
            self.get_selected_active_layers
        )
    
        # Update the display with a list of map layers within the selected thema
        self.dlg.themaView.selectionModel().selectionChanged.connect(
            self.show_thema_layers
        )
        # TODO: what does this do?
        self.dlg.themaView.selectionModel().select(
            self.themaModel.index(0,0), QtCore.QItemSelectionModel.Select | QtCore.QItemSelectionModel.Rows
        )
        self.dlg.themaView.doubleClicked.connect(
            lambda: self.load_thema_layers()
        )  # Using lambda here to prevent sending signal parameters to the loadService() function

        # All layers
        self.dlg.mapListView.selectionModel().selectionChanged.connect(
            self.get_current_layer
        )
        self.dlg.mapListView.doubleClicked.connect(
            lambda: self.load_layer(None)
        )  # Using lambda here to prevent sending signal parameters to the loadService() function

        self.dlg.stylingGroupBox.setToolTip("Selecteer maar één laag om de styling aan te passen")
        # Tracking and updating
        # QgsProject.instance().layersAdded.connect(lambda: self.update_active_layers_list())
        # QgsProject.instance().layersRemoved.connect(lambda: self.update_active_layers_list())
        # QgsProject.instance().layersRemoved.connect(lambda: self.update_active_layers_list())
        # bridge = self.iface.layerTreeCanvasBridge() 
        # self.iface.layerTreeCanvasBridge().canvasLayersChanged.connect(lambda: self.update_active_layers_list())
        self.iface.mapCanvas().layersChanged.connect(lambda: self.update_active_layers_list())


#########################################################################################
################################  General utility functions ########################
#########################################################################################


    def active_buttons(self, tabIndex):
        """Show or hide the load layers or themas buttons at the bottom"""
        if tabIndex == 1 or tabIndex == 2:
            self.dlg.load_button.show()
            self.dlg.load_close_button.show()
        else:
            self.dlg.load_button.hide()
            self.dlg.load_close_button.hide()

    def load_button_pressed(self, close):
        """Load the layers or thema when the button is pressed in the corresponding tab"""
        tab_index = self.dlg.tabWidget.currentIndex()
        
        if tab_index == 1:
            self.load_thema_layers()
        elif tab_index == 2:
            self.load_layer(None)
        if close:
            self.dlg.hide()

    def filter_layers(self, string):
        # remove selection if one row is selected
        # self.log(f"Function filter_layers: input string is {string}")
        self.dlg.mapListView.selectRow(0)
        self.proxyModel.setFilterCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
        strlist = string.strip().split(" ")
        string = ""
        for s in strlist:
            string += f"{s}.*"
        regexp = QRegularExpression(string, QRegularExpression.PatternOption.CaseInsensitiveOption | QRegularExpression.PatternOption.InvertedGreedinessOption)
        # self.log(f"The regexp to filter on is: {regexp}")
        self.proxyModel.setFilterRegularExpression(regexp)
        self.proxyModel.insertRow

    def log(self, text, lvl = 0):
        if not isinstance(text, str):
            text = str(text)
        
        log = QStandardItem(text)
        log.setToolTip(text)
        # print(text)
        QgsMessageLog.logMessage(text, PLUGIN_NAME, lvl)
        self.logModel.appendRow(
            [log]
        )

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&NAD Waterketen Kaarten'),
                action)
            self.iface.removeToolBarIcon(action)

    # General add_action function to add action-buttons to the QGIS toolbar
    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action
    
    # General translation function (can probably be deleted)
    def tr(self, message):

        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('NADMaps', message)
    

    # def beoordeling(self, star):
    #     # Hier kun je de beoordeling opslaan of uitvoeren
    #     # self.log(f"Beoordeling: {star}")
    # https://doc.qt.io/qt-6/stylesheet-examples.html
    # def update_favorite(self, thema):
    #     """Update the number of stars that a thema gets"""
    #     # self.log(thema["thema_name"])
    #     stars = 0
    #     # if thema["score"]:
    #     #     stars = thema["score"]
    #     widget = QWidget()
    #     layout_stars = QHBoxLayout()
    #     size_hint = QSize(22, 22)
    #     for i in range(5):
    #         star = QPushButton(str(""))
    #         star.setCheckable(True)
    #         if i > stars:
    #             icon = self.outlined_star
    #         else:
    #             icon = self.filled_star
    #         star.setIcon(icon)
    #         star.setFixedSize(size_hint)
    #         star.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
    #         star.clicked.connect(lambda: self.beoordeling(i))
    #         layout_stars.addWidget(star)
    #     widget.setLayout(layout_stars)
    #     widget = self.update_favorite(thema)
    #     # self.log(f"Result widget is {widget}")
    #     self.dlg.themaView.setIndexWidget(itemFavorite.index(), widget)
    #     return widget

# -*- coding: utf-8 -*-
"""
/***************************************************************************
 NADMaps
                                 A QGIS plugin
 Centrale plek om handige kaarten voor waterketen en rioolbeheer te vinden en snel in te laden.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-01-09
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Netwerk Waterketen Delfland
        email                : dataplatform@waterketendelfland.nl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import Qt, QSettings, QTranslator, QCoreApplication, QSortFilterProxyModel
from qgis.PyQt.QtGui import QIcon, QStandardItemModel, QStandardItem
from qgis.PyQt import QtWidgets
# from qgis.PyQt import QtCore, QtGui, 
# https://api.qgis.org/api/group__core.html
from qgis.core import (
    Qgis,
    QgsProject,
    QgsLayerTreeLayer,
    QgsRasterLayer,
    QgsMessageLog,
    QgsVectorLayer,
    QgsVectorTileLayer,
    QgsCoordinateReferenceSystem,
    QgsPointXY
)
from qgis.PyQt.QtWidgets import (
    QSizePolicy,
    QAction,
    QAbstractItemView,
    QPushButton,
    QDialog,
    QGridLayout,
    QDialogButtonBox,
)
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .nad_maps_dialog import NADMapsDialog
import os.path
import json
import urllib.request, urllib.parse, urllib.error
from .lib.constants import PLUGIN_NAME, PLUGIN_ID


class NADMaps(object):
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        self.dlg = NADMapsDialog(parent=self.iface.mainWindow())
        self.dlg.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Maximum)
        # initialize locale (find language of the user)
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'NADMaps_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&NAD Waterketen Kaarten')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        self.current_layer = None

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        self.run_icon = QIcon(
            os.path.join(self.plugin_dir, "resources", "nad.png")
        )

        self.add_action(
            icon_path = self.run_icon,
            text=PLUGIN_NAME,
            callback=self.run,
            parent=self.iface.mainWindow())

        # Set default layer loading behaviour
        self.service_type_mapping = {
            "wms": "WMS",
            "wmts": "WMTS",
            "wfs": "WFS",
            "wcs": "WCS",
            "api features": "OGC API - Features",
            "api tiles": "OGC API - Tiles",
        }
        # Set default layer loading behaviour
        self.default_tree_locations = {
            "wms": "top",
            "wmts": "bottom",
            "wfs": "top",
            "wcs": "top",
            "api features": "top",
            "api tiles": "bottom",
        }
        
        self.municipality_list = {
            "NAD regio": [200000, 83700, 447000],
            "Delft": [44000, 84800, 446000],
            "Den Haag": [80000, 81800, 454100],
            "Lansingerland": [70000, 94000, 447400],
            "Leidschendam-Voorburg": [50000, 88600, 456500],
            "Maassluis": [30000, 76300, 438200],
            "Midden-Delfland": [70000, 81300, 442700],
            "Pijnacker-Nootdorp": [60000, 88800, 447900],
            "Rijswijk": [35000, 82800, 450500],
            "Schiedam": [40000, 86000, 438000],
            "Vlaardingen": [40000, 82400, 437400],
            "Westland": [80000, 74200, 446700],
            "Zoetermeer": [45000, 94000, 453000],
        }
        # will be set True in run()
        self.maps_loaded = False

    def log(self, text: str, lvl = 0):
        # if not isinstance(text, str):
        #     return
        log = QStandardItem(text)
        # print(text)
        QgsMessageLog.logMessage(text, PLUGIN_NAME, lvl)
        self.logModel.appendRow(
            [log]
        )

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&NAD Waterketen Kaarten'),
                action)
            self.iface.removeToolBarIcon(action)

    def add_source_row(self, serviceLayer):
        # you can attache different "data's" to to an QStandarditem
        # default one is the visible one:
        stype = (
            self.service_type_mapping[serviceLayer["service_type"]]
            if serviceLayer["service_type"] in self.service_type_mapping
            else serviceLayer["service_type"].upper()
        )
        itemType = QStandardItem(str(stype))
        # userrole is a free form one:
        # only attach the data to the first item
        # service layer = a dict/object with all props of the layer
        # https://www.riverbankcomputing.com/static/Docs/PyQt4/qt.html#ItemDataRole-enum
        itemType.setData(serviceLayer, Qt.ItemDataRole.UserRole)
        itemType.setToolTip(f'{stype} - {serviceLayer["title"]}')
        # only wms services have styles (sometimes)
        layername = serviceLayer["title"]
        styles_string = ""
        if "styles" in serviceLayer:
            styles_string = " ".join(
                [" ".join(x.values()) for x in serviceLayer["styles"]]
            )

        itemLayername = QStandardItem(str(serviceLayer["title"]))
        itemLayername.setToolTip(f'{stype} - {serviceLayer["service_title"]}')
        # itemFilter is the item used to search filter in. That is why layername is a combi of layername + filter here
        itemFilter = QStandardItem(
            f'{serviceLayer["service_type"]} {layername} {serviceLayer["service_title"]} {serviceLayer["service_abstract"]} {styles_string}'
        )
        itemServicetitle = QStandardItem(str(serviceLayer["service_title"]))
        itemServicetitle.setToolTip(f'{stype} - {serviceLayer["title"]}')
        self.sourceModel.appendRow(
            [itemLayername, itemType, itemServicetitle, itemFilter]
        )


    def load_layer(self, tree_location=None):
        """Adds a QgsLayer to the project and layer tree.
        tree_location can be 'default', 'top', 'bottom'
        """
        self.log(f"Inside function load_layer")
        if self.current_layer is None:
            self.log("self.current_layer is None")
            return

        servicetype = self.current_layer["service_type"]
        if tree_location is None:
            tree_location = self.default_tree_locations[servicetype]
        
        new_layer = self.create_new_layer()
        if new_layer is None:
            return
        
        if tree_location not in ["default", "top", "bottom"]:
            # TODO: proper error handling
            return
        if tree_location == "default":
            QgsProject.instance().addMapLayer(new_layer, True)
            return
        QgsProject.instance().addMapLayer(new_layer, False)
        new_layer_tree_layer = QgsLayerTreeLayer(new_layer)
        layer_tree = self.iface.layerTreeCanvasBridge().rootGroup()
        if tree_location == "top":
            layer_tree.insertChildNode(0, new_layer_tree_layer)
        if tree_location == "bottom":
            layer_tree.insertChildNode(-1, new_layer_tree_layer)

    def load_qml_style(self, layer, styling):
        if not styling:
            return
        else:
            folder = "resources\\styling"
            self.log(folder)
            qmlpad = os.path.join(self.plugin_dir, folder, styling) + ".qml"
            layer.loadNamedStyle(qmlpad)
            layer.triggerRepaint()
            # print(layer.name())
            self.log(qmlpad)
        # self.configure_dropdown()
    
    def create_new_layer(self):
        servicetype = self.current_layer["service_type"]
        title = self.current_layer["title"]
        layername = self.current_layer["name"]
        url = self.current_layer["service_url"]

        if servicetype == "wms":
            return self.create_wms_layer(layername, title, url)
        elif servicetype == "wmts":
            return self.create_wmts_layer(layername, title, url, servicetype)
        elif servicetype == "wfs":
            layer = self.create_wfs_layer(layername, title, url)
            self.log(f"layer data type is {str(type(layer))}")
            # styling = self.current_layer["styling"]
            # self.log(f"styling is {str(styling)}")
            # if styling and styling != "":
            #     # something
            #     self.log(f"here")
            #     self.load_qml_style(layer, styling)
            # else:
            #     self.log(f"here")
            #     return

            return layer
        elif servicetype == "wcs":
            return self.create_wcs_layer(layername, title, url)
        elif servicetype == "api features":
            return self.create_oaf_layer(layername, title, url)
        elif servicetype == "api tiles":
            return self.create_oat_layer(title, url)
        else:
            self.show_warning(
                f"""Sorry, dit type laag: '{servicetype.upper()}'
                kan niet worden geladen door de plugin of door QGIS.
                Is het niet beschikbaar als wms, wmts, wfs, api features of api tiles (vectortile)?
                """
            )
            return

    def create_wfs_layer(self, layername, title, url):
        uri = f" pagingEnabled='true' restrictToRequestBBOX='1' srsname='EPSG:28992' typename='{layername}' url='{url}' version='2.0.0'"
        return QgsVectorLayer(uri, title, "wfs")

    def create_wms_layer(self, layername, title, url):
        imgformat = self.current_layer["imgformats"].split(",")[0]
        crs = "EPSG:28992"

        selected_style_name = "default"
        uri = f"crs={crs}&layers={layername}&styles={selected_style_name}&format={imgformat}&url={url}"
        # crs=EPSG:28992&layers=top25raster&styles=default&format=image/png&url=https://service.pdok.nl/brt/topraster/wms/v1_0?request=GetCapabilities&service=WMS
        return QgsRasterLayer(uri, title, "wms")

    def create_wcs_layer(self, layername, title, url):
        # HACK to get WCS to work:
        # 1) fixed format to "GEOTIFF"
        # 2) remove the '?request=getcapabiliteis....' part from the url, unknown why this is required compared to wms/wfs
        # better approach would be to add the supported format(s) to the layers-pdok.json file and use that - this should be the approach when more
        # WCS services will be published by PDOK (currently it is only the AHN WCS)
        format = "GEOTIFF"
        uri = f"cache=AlwaysNetwork&crs=EPSG:28992&format={format}&identifier={layername}&url={url.split('?')[0]}"
        return QgsRasterLayer(uri, title, "wcs")

    def build_tileset_url(self, url, tileset_id, for_request):
        url_template = url + "/tiles/" + tileset_id
        if for_request:
            return url_template + "/%7Bz%7D/%7By%7D/%7Bx%7D?f%3Dmvt"
        return url_template + "/{z}/{y}/{x}?f=mvt"

    def create_oat_layer(self, title, url):
        # CRS does not work as expected in qgis/gdal. We can set a crs (non-webmercator), but it is rendered incorrectly.
        crs = "EPSG:28992"
        used_tileset = [
            tileset
            for tileset in self.current_layer["tiles"][0]["tilesets"]
            if tileset["tileset_crs"].endswith(crs.split(":")[1])
        ][0]

        # Style toevoegen in laag vanuit ui
        # selected_style = self.get_selected_style()
        # selected_style_url = "bgt_standaardvisualisatie__netherlandsrdnewquad"
        name = self.current_layer["styles"][0]["name"]
        self.log(f"name is {name}")
        self.log(f"old title is {title}")
        title += f" [{name}]"
        self.log(f"new title is {title}")
        selected_style_url = self.current_layer["styles"][0]["url"]
        self.log(f"selected_style_url is {selected_style_url}")

        # if selected_style is not None:
        #     selected_style_url = selected_style["url"]
        #     title += f" [{selected_style['name']}]"

        url_template = self.build_tileset_url(url, used_tileset["tileset_id"], True)
        self.log(f"url_template is {url_template}")
        
        maxz_coord = used_tileset["tileset_max_zoomlevel"]

        # Although the vector tiles are only rendered for a specific zoom-level @PDOK (see maxz_coord),
        # we need to set the minimum z value to 0, which gives better performance, see https://github.com/qgis/QGIS/issues/54312
        minz_coord = 0

        type = "xyz"
        uri = f"styleUrl={selected_style_url}&url={url_template}&type={type}&zmax={maxz_coord}&zmin={minz_coord}&http-header:referer="
        tile_layer = QgsVectorTileLayer(uri, title)
        # styleUrl=https://api.pdok.nl/lv/bag/ogc/v1_0/styles/bag_standaardvisualisatie__netherlandsrdnewquad?f=mapbox&url=https://api.pdok.nl/lv/bag/ogc/v1_0/tiles/WebMercatorQuad/%7Bz%7D/%7By%7D/%7Bx%7D?f%3Dmvt&type=xyz&zmax=17&zmin=0&http-header:referer=
        # Set the VT layer CRS and load the styleUrl
        tile_layer.setCrs(srs=QgsCoordinateReferenceSystem(crs))
        tile_layer.loadDefaultStyle()
        return tile_layer

    def create_wmts_layer(self, layername, title, url, servicetype):
        if Qgis.QGIS_VERSION_INT < 10900:
            self.show_warning(
                f"""Sorry, dit type layer: '{servicetype.upper()}'
                kan niet worden geladen in deze versie van QGIS.
                Misschien kunt u QGIS 2.0 installeren (die kan het WEL)?
                Of is de laag niet ook beschikbaar als wms of wfs?"""
            )
            return None
        url = self.quote_wmts_url(url)
        imgformat = self.current_layer["imgformats"].split(",")[0]
        # some fiddling with tilematrixset names and crs's (which sometimes are the same, but other times are not)
        tilematrixset = self.current_layer["tilematrixsets"]
        if tilematrixset.startswith("EPSG:"):
            crs = tilematrixset
            i = crs.find(":", 5)
            if i > -1:
                crs = crs[:i]
        elif tilematrixset.startswith("OGC:1.0"):
            crs = "EPSG:3857"
        else:
            # non PDOK services do not have a strict tilematrixset naming based on crs...
            crs = self.current_layer["crs"]

        uri = f"crs={crs}&tileMatrixSet={tilematrixset}&layers={layername}&styles=default&format={imgformat}&url={url}"
        return QgsRasterLayer(
            uri, title, "wms"
        )  # LET OP: `wms` is correct, zie ook quote_wmts_url

    def quote_wmts_url(self, url):
        """
        Quoten wmts url is nodig omdat qgis de query param `SERVICE=WMS` erachter plakt als je de wmts url niet quote.
        Dit vermoedelijk omdat de wmts laag wordt toegevoegd mbv de wms provider: `return QgsRasterLayer(uri, title, "wms")`.
        Wat op basis van de documentatie wel de manier is om een wmts laag toe te voegen.
        """
        parse_result = urllib.parse.urlparse(url)
        location = f"{parse_result.scheme}://{parse_result.netloc}/{parse_result.path}"
        query = parse_result.query
        query_escaped_quoted = urllib.parse.quote_plus(query)
        url = f"{location}?{query_escaped_quoted}"
        return url

    def zoom_to(self):
        """Zoom to desired location"""
        self.log("inside zoom_to function")
        region = self.dlg.zoomComboBox.currentText()
        scale, x, y = self.municipality_list[region]
        # self.iface.mapCanvas().zoomScale(200000)
        # self.iface.mapCanvas().setCenter(QgsPointXY(83700, 447000))
        self.iface.mapCanvas().zoomScale(scale)
        self.iface.mapCanvas().setCenter(QgsPointXY(x, y))
        # https://api.qgis.org/api/classQgsMapCanvas.html

    # TODO: First implement the UI
    def delete_thema(self):
        """Delete an existing thema (only user defined themas should be deleted)"""
        self.log("Starting the delete_thema function")
        self.log("Finished the delete_thema function")

    # TODO: Something goes wrong (saving data double for each extra selection)
    def save_thema(self):
        """Save a collection of layers in order to later quickly load them"""
        self.log("Starting the save_thema function")
        folder = "resources\\themas"
        filename = "default.json"
        thema_path = os.path.join(self.plugin_dir, folder, filename)
        if not os.path.isfile(thema_path):
            with open(thema_path, 'w', encoding='utf-8') as f:
                json.dump([], f)
        
        # Collect a json string with a thema_name and a list of layer names
        thema_name = self.dlg.saveThemaLineEdit.text()

        string = "{\"thema_name\": \"" + thema_name + "\", "
        string = string + "\"layers\": ["

        # https://doc.qt.io/qt-6/qabstractitemmodel.html#details # documentation p1
        # https://doc.qt.io/qt-6/qt.html#ItemDataRole-enum # documentation p2
        selected_layers = self.dlg.mapListView.selectionModel().selectedRows()
        for i, r in enumerate(selected_layers):
            current_layer = r.siblingAtColumn(0).data(Qt.ItemDataRole.DisplayRole)
            string = string + "\"" + current_layer + "\""
            if i == len(selected_layers) - 1:
                string = string + "]"
            else:
                string = string + ", "
        string = string + "}"
        self.log(string)

        data = json.loads(string)
        # https://stackoverflow.com/questions/12994442/how-to-append-data-to-a-json-file
        with open(thema_path, mode='r', encoding='utf-8') as feedsjson:
            feeds = json.load(feedsjson)
        with open(thema_path, mode='w', encoding='utf-8') as feedsjson:
            feeds.append(data)
            json.dump(feeds, feedsjson, indent='\t')
        
        self.update_thema_list(data)
        self.log("Finished the save_thema function")

    def update_thema_list(self, thema):
        """Add a thema to the thema model"""
        if isinstance(thema["thema_name"], str):
            # layers_string = ""
            # if "layers" in thema:
            #     layers_string = " ".join(
            #         [" ".join(x.values()) for x in thema["layers"]]
            #     )
            itemThema = QStandardItem(str(thema["thema_name"]))
            itemFilter = QStandardItem(f'{thema["thema_name"]} {thema["layers"]}')
            # https://doc.qt.io/qt-6/qstandarditem.html#setData
            itemThema.setData(thema, Qt.ItemDataRole.UserRole)
            self.themaModel.appendRow(
                [itemThema, itemFilter]
            )


    def show_layer(self, selectedIndexes):
        self.log(f"show_layer: len(selectedIndexes) is {str(len(selectedIndexes))}")
        if len(selectedIndexes) == 0:
            self.current_layer = None
            return

        self.dlg.mapListView.scrollTo(self.dlg.mapListView.selectedIndexes()[0])
        # itemType holds the data (== column 1) hence self.dlg.mapListView.selectedIndexes()[1], see itemType.setData(serviceLayer, Qt.ItemDataRole.UserRole)
        self.current_layer = self.dlg.mapListView.selectedIndexes()[1].data(
            Qt.ItemDataRole.UserRole
        )


    def show_thema_layers(self, selectedIndexes):
        """Show the layers that are part of a thema"""
        self.log(f"show_thema_layers: len(selectedIndexes) is {str(len(selectedIndexes))}")
        if len(selectedIndexes) == 0:
            self.current_layer = None
            return
        
        self.current_thema = self.dlg.themaView.selectedIndexes()[0].data(
            Qt.ItemDataRole.UserRole
        )
        # wmts Luchtfoto Actueel Ortho 25cm RGB Landelijke Voorziening Beeldmateriaal Een jaarlijks te vernieuwen dataset van luchtopnamen van Nederland in hoge en lage resolutie.  default
        layers = self.current_thema["layers"]
        layer_path = os.path.join(self.plugin_dir, "resources", "layers-nad.json")
        self.thema_layers = []
        for layer in layers:
            with open(layer_path, "r", encoding="utf-8") as f:
                all_layers = json.load(f)
                for i, r in enumerate(all_layers):
                    title = all_layers[i]["title"]
                    if layer == title:
                        self.thema_layers.append(all_layers[i])
        self.update_thema_layers()
        self.log("Finished the show_thema_layers function")


    def load_thema_layers(self):
        """Load the layers of this thema to the canvas"""
        self.log(f"load_thema_layers: current_thema is {self.current_thema["thema_name"]}")
        thema_layers = self.thema_layers
        for layer in thema_layers:
            name = layer["name"]
            self.log(name)
            self.current_layer = layer
            # self.load_layer(None)
            self.load_layer(None)
        self.log("Finished the load_thema_layers function")


    def update_thema_layers(self):
        """Update the list of layers contained with this thema"""
        thema_layers = self.thema_layers
        
        self.themaMapModel.clear()

        for layer in thema_layers:
            itemLayername = QStandardItem(str(layer["title"]))
            stype = (
                self.service_type_mapping[layer["service_type"]]
                if layer["service_type"] in self.service_type_mapping
                else layer["service_type"].upper()
            )
            itemType = QStandardItem(str(stype))
            itemServicetitle = QStandardItem(str(layer["service_title"]))
            self.themaMapModel.appendRow(
                [itemLayername, itemType, itemServicetitle]
            )
            
        self.themaMapModel.setHeaderData(2, Qt.Orientation.Horizontal, "Service")
        self.themaMapModel.setHeaderData(1, Qt.Orientation.Horizontal, "Type")
        self.themaMapModel.setHeaderData(0, Qt.Orientation.Horizontal, "Laagnaam")
        self.themaMapModel.horizontalHeaderItem(2).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.themaMapModel.horizontalHeaderItem(1).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.themaMapModel.horizontalHeaderItem(0).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.dlg.themaMapListView.horizontalHeader().setStretchLastSection(True)
        
        self.dlg.themaMapListView.setColumnWidth(
            0, 200
        )  # set name to 300px (there are some huge layernames)
        self.dlg.themaMapListView.horizontalHeader().setStretchLastSection(True)


    def run(self, hiddenDialog=False):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.maps_loaded == False:
            # general functions
            self.dlg.zoomComboBox.addItems(self.municipality_list)
            self.dlg.zoomButton.clicked.connect(lambda: self.zoom_to())
            self.maps_loaded = True
            
            self.logModel = QStandardItemModel()
            self.dlg.logView.setModel(self.logModel)
            self.dlg.logView.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
            self.log('started logging')

            # thema tab
            # self.themaModel = QStandardItemModel()
            
            ### thema list
            self.themaModel = QStandardItemModel()
            self.styleFilterThema = QSortFilterProxyModel()
            self.styleFilterThema.setSourceModel(self.themaModel)
            self.styleFilterThema.setFilterKeyColumn(2)

            self.proxyModelThema = QSortFilterProxyModel()
            self.proxyModelThema.setSourceModel(self.styleFilterThema)
            self.proxyModelThema.setFilterKeyColumn(1)

            self.dlg.themaView.setModel(self.themaModel)
            self.dlg.themaView.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
            
            self.themas_nad = []
            thema_path = os.path.join(self.plugin_dir, "resources\\themas", "default.json")
            with open(thema_path, "r", encoding="utf-8") as f:
                self.themas_nad.extend(json.load(f))
            
            for thema in self.themas_nad:
                self.update_thema_list(thema)

            # execute function to update the thema list (if during this session we save more themas then we can update this list again)
            self.dlg.themaView.selectionModel().selectionChanged.connect(
                self.show_thema_layers
            )
            ### thema layers list
            self.themaMapModel = QStandardItemModel()
            self.styleFilterThemaMaps = QSortFilterProxyModel()
            self.styleFilterThemaMaps.setSourceModel(self.themaMapModel)
            self.styleFilterThemaMaps.setFilterKeyColumn(4)
            
            self.proxyModelThemaMaps = QSortFilterProxyModel()
            self.proxyModelThemaMaps.setSourceModel(self.styleFilterThemaMaps)
            self.proxyModelThemaMaps.setFilterKeyColumn(3)

            self.dlg.themaMapListView.setModel(self.themaMapModel)
            self.dlg.themaMapListView.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)

            self.dlg.themaView.selectionModel().select(self.themaModel.index(0,0), QtCore.QItemSelectionModel.Select | QtCore.QItemSelectionModel.Rows)
            self.dlg.themaView.doubleClicked.connect(
                lambda: self.load_thema_layers()
            )  # Using lambda here to prevent sending signal parameters to the loadService() function

            
            # layers tab
            self.layers_nad = []
            layer_path = os.path.join(self.plugin_dir, "resources", "layers-nad.json")
            with open(layer_path, "r", encoding="utf-8") as f:
                self.layers_nad.extend(json.load(f))

            self.sourceModel = QStandardItemModel()
            self.styleFilter = QSortFilterProxyModel()
            self.styleFilter.setSourceModel(self.sourceModel)
            self.styleFilter.setFilterKeyColumn(4)

            self.proxyModel = QSortFilterProxyModel()
            self.proxyModel.setSourceModel(self.styleFilter)
            self.proxyModel.setFilterKeyColumn(3)

            self.dlg.mapListView.setModel(self.sourceModel)
            self.dlg.mapListView.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)

            for layer in self.layers_nad:
                if isinstance(layer["name"], str):
                    self.add_source_row(layer)

            self.dlg.mapListView.selectionModel().selectionChanged.connect(
                self.show_layer
            )
            self.dlg.mapListView.doubleClicked.connect(
                lambda: self.load_layer(None)
            )  # Using lambda here to prevent sending signal parameters to the loadService() function
            
            self.dlg.saveThemaButton.clicked.connect(lambda: self.save_thema())

            self.dlg.themaView.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            self.dlg.mapListView.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            self.dlg.mapListView.verticalHeader().setSectionsClickable(False)
            self.dlg.mapListView.horizontalHeader().setSectionsClickable(False)
            # hide itemFilter column:
            self.dlg.mapListView.hideColumn(3)
            self.dlg.themaView.hideColumn(1)
            self.dlg.themaMapListView.hideColumn(3)

        # self.themaModel.setHeaderData(1, Qt.Orientation.Horizontal, "Omschrijving")
        self.themaModel.setHeaderData(0, Qt.Orientation.Horizontal, "Thema's")
        # self.themaModel.horizontalHeaderItem(1).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.themaModel.horizontalHeaderItem(0).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.dlg.themaView.horizontalHeader().setStretchLastSection(True)

        self.themaMapModel.setHeaderData(2, Qt.Orientation.Horizontal, "Service")
        self.themaMapModel.setHeaderData(1, Qt.Orientation.Horizontal, "Type")
        self.themaMapModel.setHeaderData(0, Qt.Orientation.Horizontal, "Laagnaam")
        self.themaMapModel.horizontalHeaderItem(2).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.themaMapModel.horizontalHeaderItem(1).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.themaMapModel.horizontalHeaderItem(0).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.dlg.themaMapListView.horizontalHeader().setStretchLastSection(True)
        
        self.dlg.themaMapListView.setColumnWidth(
            0, 200
        )  # set name to 300px (there are some huge layernames)
        self.dlg.themaMapListView.horizontalHeader().setStretchLastSection(True)

        self.logModel.setHeaderData(0, Qt.Orientation.Horizontal, "Log bericht")
        self.logModel.horizontalHeaderItem(0).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.dlg.logView.horizontalHeader().setStretchLastSection(True)
        
        self.sourceModel.setHeaderData(2, Qt.Orientation.Horizontal, "Service")
        self.sourceModel.setHeaderData(1, Qt.Orientation.Horizontal, "Type")
        self.sourceModel.setHeaderData(0, Qt.Orientation.Horizontal, "Laagnaam")
        self.sourceModel.horizontalHeaderItem(2).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.sourceModel.horizontalHeaderItem(1).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.sourceModel.horizontalHeaderItem(0).setTextAlignment(Qt.AlignmentFlag.AlignLeft)

        self.dlg.mapListView.setColumnWidth(
            0, 200
        )  # set name to 300px (there are some huge layernames)
        self.dlg.mapListView.horizontalHeader().setStretchLastSection(True)
        # self.dlg.mapListView.resizeColumnsToContents()
        # show the dialog
        if not hiddenDialog:
            self.dlg.show()



    # TODO: function to export current canvas as pdf or image
    def save_canvas(self):
        """Export the current map to pdf or png, including a north-arrow"""
        # qgis.utils.iface.mapCanvas().saveAsImage('test.png', None, 'PNG') 

    # General translation function (can probably be deleted)
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('NADMaps', message)

    # General add_action function to add action-buttons to the QGIS toolbar
    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action
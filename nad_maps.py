# -*- coding: utf-8 -*-
"""
/***************************************************************************
 NADMaps
                                 A QGIS plugin
 Centrale plek om handige kaarten voor waterketen en rioolbeheer te vinden en snel in te laden.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-01-09
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Netwerk Waterketen Delfland
        email                : dataplatform@waterketendelfland.nl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# General packages
import getpass
import os.path
from qgis.core import QgsCoordinateReferenceSystem, QgsProject
from qgis.PyQt.QtCore import QCoreApplication, QSettings, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QSizePolicy, QMessageBox

from .lib.constants import PLUGIN_NAME, ADMIN_USERNAMES, PAPER_OPTIONS, FORMAT_OPTIONS

from .gui.nad_maps_dialog import NADMapsDialog
from .gui.nad_maps_popup import NADMapsPopup

# from .lib.load_layers import LoadLayers ### LayerManager
from .lib.layer import LayerManager
from .lib.thema import ThemaManager
from .lib.style import StyleManager
from .lib.log import LoggingManager
from .lib.export import ExportManager
from .lib.search_location import SearchLocationManager
### ExportManager


#########################################################################################
####################  Run main script to initiate when NAD button is pressed ############
#########################################################################################

class NADMaps(object):
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        self.dlg = NADMapsDialog(parent=self.iface.mainWindow())
        self.popup = NADMapsPopup(parent=self.iface.mainWindow())
        self.dlg.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Maximum)

        if getpass.getuser() in ADMIN_USERNAMES:
            self.creator = "Plugin"
        else:
            self.creator = getpass.getuser()

        # initialize the working directory from settings
        self.working_dir = QSettings().value('NADmaps/working_dir')
        while self.working_dir in ["", None]:
            self.working_dir = QFileDialog.getExistingDirectory(self.dlg, "Selecteer een werkmap", "")           
        
        os.makedirs(self.working_dir, exist_ok=True)
        os.makedirs(os.path.join(self.working_dir, "styling"), exist_ok=True)
        os.makedirs(os.path.join(self.working_dir, "styling\\qml_files"), exist_ok=True)

        # save the working directory to the settings, such that it is available next time the plugin is started
        QSettings().setValue("NADmaps/working_dir", self.working_dir)
        self.dlg.lineEditFilePath.setText(self.working_dir)

        self.user_styling_path = os.path.join(self.working_dir, "styling", "styling.json")
        self.user_styling_files_path = os.path.join(self.working_dir, "styling", "qml_files")
        self.plugin_styling_path = os.path.join(self.plugin_dir, "resources", "styling", "styling.json")
        self.plugin_styling_files_path = os.path.join(self.plugin_dir, "resources", "styling", "qml_files")

        self.log_manager = LoggingManager(dlg=self.dlg)
        self.log = self.log_manager.log

        self.style_manager = StyleManager(dlg=self.dlg, popup=self.popup, plugin_dir=self.plugin_dir, working_dir=self.working_dir, creator=self.creator, log=self.log)
        self.search_manager = SearchLocationManager(dlg=self.dlg, iface=self.iface, log=self.log)
        self.layer_manager = LayerManager(dlg=self.dlg, iface=self.iface, plugin_dir=self.plugin_dir, tr=self.tr, style_manager=self.style_manager, log=self.log)
        self.thema_manager = ThemaManager(dlg=self.dlg, popup=self.popup, plugin_dir=self.plugin_dir, working_dir=self.working_dir, creator=self.creator, log=self.log)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&NAD Waterketen Kaarten')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        # will be set True in run()
        self.setup_completed = False
        self.current_layer = None
        self.selected_active_layers = None

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        self.run_icon = QIcon(
            os.path.join(self.plugin_dir, "resources", "nad.png")
        )

        self.add_action(
            icon_path = self.run_icon,
            text=PLUGIN_NAME,
            callback=self.run,
            parent=self.iface.mainWindow())


#########################################################################################
####################  Run main script to initiate when NAD button is pressed ############
#########################################################################################

    def run(self, hiddenDialog=False):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.setup_completed == False:
            # setup the (proxy)models
            self.setup_interactions()
            
            # create an initial list of active layers
            self.layer_manager.update_active_layers_list()
            
            # create a list of existing themas
            self.thema_manager.update_thema_list()

            # Create a list of all layers available via the plugin
            self.layer_manager.load_layer_list()

            # TODO: set projection to ESPG:28992
            projectCrs = QgsCoordinateReferenceSystem.fromEpsgId(28992)
            QgsProject.instance().setCrs(projectCrs)
            self.setup_completed = True
        
        # set which buttons should be shown
        tab_index = self.dlg.tabWidget.currentIndex()
        self.active_buttons(tab_index)

        # init the values for the export settings
        self.init_export_comboboxes()
        self.load_export_settings()
        self.check_map_name() # To enable or disable pushbutton

        # show the dialog
        if not hiddenDialog:
            self.dlg.show()

    # TODO: function to export current canvas as pdf or image
    def export_canvas(self):
        """Export the current map to pdf or png, including a north-arrow"""
        # qgis.utils.iface.mapCanvas().saveAsImage('test.png', None, 'PNG') 
        # https://qgis.org/pyqgis/3.40/gui/QgsMapCanvas.html#qgis.gui.QgsMapCanvas


#########################################################################################
#################################  Setup functions ######################################
#########################################################################################


    def setup_interactions(self):
        """
        This does a setup of all the button interactions.
        """
        # Click functions
        self.dlg.loadStyleButton.clicked.connect(lambda: self.style_manager.load_styling())
        self.dlg.loadStyleButton.clicked.connect(lambda: self.layer_manager.update_active_layers_list())
        self.dlg.removeStyleButton.clicked.connect(lambda: self.style_manager.delete_styling())
        self.dlg.removeStyleButton.clicked.connect(lambda: self.layer_manager.update_active_layers_list())
        self.dlg.saveStyleButton.clicked.connect(lambda: self.style_manager.check_existing_style())
        self.dlg.saveStyleButton.clicked.connect(lambda: self.layer_manager.update_active_layers_list())

        self.dlg.saveThemaButton.setEnabled(False)
        self.dlg.saveThemaButton.setToolTip("Geen lagen geselecteerd")
        self.dlg.saveThemaButton.clicked.connect(
            lambda: self.thema_manager.save_thema(False, selected_active_layers = self.selected_active_layers)
        )
        self.dlg.saveAllThemaButton.clicked.connect(
            lambda: self.thema_manager.save_thema(True, selected_active_layers = self.selected_active_layers)
        )

        self.dlg.pluginThemaCheckBox.clicked.connect(lambda: self.thema_manager.filter_thema_list())
        self.dlg.userThemaCheckBox.clicked.connect(lambda: self.thema_manager.filter_thema_list())
        self.dlg.favoriteThemaCheckBox.clicked.connect(lambda: self.thema_manager.filter_thema_list())
        
        self.dlg.deleteThemaButton.clicked.connect(lambda: self.thema_manager.delete_thema())

        self.dlg.tabWidget.currentChanged.connect(self.active_buttons)
        self.dlg.load_button.clicked.connect(lambda: self.load_button_pressed(False))
        self.dlg.load_close_button.clicked.connect(lambda: self.load_button_pressed(True))
        self.dlg.close_button.clicked.connect(lambda: self.dlg.hide())

        # Set working directory by using the file dialog to select a folder
        self.dlg.set_working_dir.clicked.connect(
            lambda: self.set_working_directory(
                QFileDialog.getExistingDirectory(self.dlg, "Selecteer een werkmap", self.working_dir)
            )
        )

        # Export_tab interactions
        self.dlg.lineEdit_MapName.textChanged.connect(self.check_map_name)
        self.dlg.comboBox_PapierFormaat.currentIndexChanged.connect(self.on_paper_format_changed)
        self.dlg.comboBox_BestandsFormaat.currentIndexChanged.connect(self.on_file_format_changed)
        self.dlg.doubleSpinBox_Rotatie.valueChanged.connect(self.on_rotation_changed)
        self.dlg.doubleSpinBox_Schaal.valueChanged.connect(self.on_scale_changed)
        self.dlg.checkBox_Noordpijl.stateChanged.connect(self.on_north_checkbox_changed)
        self.dlg.checkBox_Legenda.stateChanged.connect(self.on_legend_checkbox_changed)
        self.dlg.checkBox_Schaalbalk.stateChanged.connect(self.on_scale_checkbox_changed)
        self.dlg.pushButton_ExporteerMap.clicked.connect(self.export_map_button_pressed)

        self.dlg.stylingGroupBox.setEnabled(False)

        self.popup.accept_button.clicked.connect(lambda: self.save_styling())
        self.popup.accept_button.clicked.connect(lambda: self.style_overwrite(False))
        self.popup.close_button.clicked.connect(lambda: self.style_overwrite(False))

        # update the information on the current selection of active layers
        self.dlg.activeMapListView.selectionModel().selectionChanged.connect(
            self.get_selected_active_layers
        )

        # self.dlg.stylingGroupBox.setToolTip("Selecteer maar één laag om de styling aan te passen")


#########################################################################################
################################  General utility functions ########################
#########################################################################################

    def set_working_directory(self, path):
        """Set the working directory for the plugin"""

        # some checks if the path is not empty or a directory
        if path == "" or path == None:
            return
        if not os.path.isdir(path):
            return
        # plugin path & user path
        os.makedirs(path, exist_ok=True)
        os.makedirs(os.path.join(path, "styling"), exist_ok=True)
        os.makedirs(os.path.join(path, "styling\\qml_files"), exist_ok=True)

        self.thema_manager.set_working_directory(path)

        self.user_styling_path = os.path.join(
            path,
            "styling\\styling.json"
        )
        self.user_styling_files_path = os.path.join(
            path,
            "styling\\qml_files"
        )

        # save the working directory to the settings, such that it is available next time the plugin is started
        QSettings().setValue("NADmaps/working_dir", path)

        self.working_dir = path
        self.dlg.lineEditFilePath.setText(path)

    def get_selected_active_layers(self):
        """
        Get the selected layers from the active layers-tab
        """
        selectedIndexes = self.dlg.activeMapListView.selectedIndexes()
        nr_of_selected_rows = len(set(index.row() for index in selectedIndexes))
        # self.log(f"nr selected rows = {nr_of_selected_rows}")

        # enable or disable the styling-functions
        if nr_of_selected_rows == 1:
            self.style_manager.update_styling_list()
            self.dlg.stylingGroupBox.setEnabled(True)
            self.dlg.stylingGroupBox.setToolTip("")
            self.dlg.saveThemaButton.setEnabled(True)
            self.dlg.saveThemaButton.setToolTip("")
        elif nr_of_selected_rows > 1:
            self.dlg.stylingGroupBox.setEnabled(False)
            self.dlg.stylingGroupBox.setToolTip("Selecteer maar één laag om de styling aan te passen")
            self.dlg.saveThemaButton.setEnabled(True)
            self.dlg.saveThemaButton.setToolTip("")
        elif nr_of_selected_rows == 0:
            self.dlg.stylingGroupBox.setEnabled(False)
            self.dlg.stylingGroupBox.setToolTip("Selecteer maar één laag om de styling aan te passen")
            self.dlg.saveThemaButton.setEnabled(False)
            self.dlg.saveThemaButton.setToolTip("Geen lagen geselecteerd")
            self.selected_active_layers = None
            return

        self.selected_active_layers = []
        first_index_list = set(index.siblingAtColumn(0) for index in selectedIndexes)
        for index in first_index_list:
            active_layer = index.data(
                    Qt.ItemDataRole.UserRole
                )
            self.selected_active_layers.append(active_layer)
            # self.log(f"selected active layers = {self.selected_active_layers}")

    def active_buttons(self, tabIndex):
        """Show or hide the load layers or themas buttons at the bottom"""
        if tabIndex == 1 or tabIndex == 2:
            self.dlg.load_button.show()
            self.dlg.load_close_button.show()
        else:
            self.dlg.load_button.hide()
            self.dlg.load_close_button.hide()

    def load_button_pressed(self, close):
        """Load the layers or thema when the button is pressed in the corresponding tab"""
        tab_index = self.dlg.tabWidget.currentIndex()
        
        if tab_index == 1:
            self.thema_manager.load_thema_layers()
        elif tab_index == 2:
            self.layer_manager.load_layer(None)
        if close:
            self.dlg.hide()

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&NAD Waterketen Kaarten'),
                action)
            self.iface.removeToolBarIcon(action)

    # General add_action function to add action-buttons to the QGIS toolbar
    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action
    
    # General translation function (can probably be deleted)
    def tr(self, message):

        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('NADMaps', message)
    
    def init_export_comboboxes(self):
        paper_items = [str(self.dlg.comboBox_PapierFormaat.itemText(i)) for i in range(self.dlg.comboBox_PapierFormaat.count())]
        file_items = [str(self.dlg.comboBox_BestandsFormaat.itemText(i)) for i in range(self.dlg.comboBox_BestandsFormaat.count())]

        if paper_items != PAPER_OPTIONS:
            self.dlg.comboBox_PapierFormaat.clear()
            for item in PAPER_OPTIONS:
                self.dlg.comboBox_PapierFormaat.addItem(item)
        
        if file_items != FORMAT_OPTIONS:
            self.dlg.comboBox_BestandsFormaat.clear()
            for item in FORMAT_OPTIONS:
                self.dlg.comboBox_BestandsFormaat.addItem(item)

    def save_export_settings(self):
        QSettings().setValue("NADmaps/export/paper_format", self.dlg.comboBox_PapierFormaat.currentText())
        QSettings().setValue("NADmaps/export/file_format", self.dlg.comboBox_BestandsFormaat.currentText())
        QSettings().setValue("NADmaps/export/rotation", str(self.dlg.doubleSpinBox_Rotatie.value()))
        QSettings().setValue("NADmaps/export/scale", str(self.dlg.doubleSpinBox_Schaal.value()))
        QSettings().setValue("NADmaps/export/include_north", "true" if self.dlg.checkBox_Noordpijl.isChecked() else "false")
        QSettings().setValue("NADmaps/export/include_legend", "true" if self.dlg.checkBox_Legenda.isChecked() else "false")
        QSettings().setValue("NADmaps/export/include_scale", "true" if self.dlg.checkBox_Schaalbalk.isChecked() else "false")

    def load_export_settings(self):
        saved_paper = str(QSettings().value("NADmaps/export/paper_format", "A4 staand"))
        if saved_paper in [str(self.dlg.comboBox_PapierFormaat.itemText(i)) for i in range(self.dlg.comboBox_PapierFormaat.count())]:
            self.dlg.comboBox_PapierFormaat.setCurrentText(saved_paper)
        else:
            self.dlg.comboBox_PapierFormaat.setCurrentIndex(0)

        saved_format = str(QSettings().value("NADmaps/export/file_format", "PNG"))
        format_items = [str(self.dlg.comboBox_BestandsFormaat.itemText(i)) for i in range(self.dlg.comboBox_BestandsFormaat.count())]
        if saved_format in format_items:
            self.dlg.comboBox_BestandsFormaat.setCurrentText(saved_format)
        else:
            self.dlg.comboBox_BestandsFormaat.setCurrentIndex(0)

        self.dlg.doubleSpinBox_Rotatie.setValue(float(QSettings().value("NADmaps/export/rotation", 0)))
        self.dlg.doubleSpinBox_Schaal.setValue(float(QSettings().value("NADmaps/export/scale", 10000)))

        self.dlg.checkBox_Noordpijl.setChecked(QSettings().value("NADmaps/export/include_north", "false") == "true")
        self.dlg.checkBox_Legenda.setChecked(QSettings().value("NADmaps/export/include_legend", "false") == "true")
        self.dlg.checkBox_Schaalbalk.setChecked(QSettings().value("NADmaps/export/include_scale", "false") == "true")

    def on_paper_format_changed(self):
        self.save_export_settings()

    def on_file_format_changed(self):
        self.save_export_settings()

    def on_rotation_changed(self):
        self.save_export_settings()

    def on_scale_changed(self):
        self.save_export_settings()

    def on_north_checkbox_changed(self):
        self.save_export_settings()

    def on_legend_checkbox_changed(self):
        self.save_export_settings()

    def on_scale_checkbox_changed(self):
        self.save_export_settings()

    def check_map_name(self):
        map_name = self.dlg.lineEdit_MapName.text()
        self.dlg.pushButton_ExporteerMap.setEnabled(bool(map_name))

    def export_map_button_pressed(self):
        file_path = self.generate_export_path()
        if not file_path:
            self.log("Geen bestandsnaam opgegeven", 1)
            return
        if os.path.exists(file_path):
            overwrite = QMessageBox.question(
                self.dlg,
                "Bestand bestaat al",
                f"Het bestand {file_path} bestaat al. Wilt u het overschrijven?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            )
            if overwrite == QMessageBox.StandardButton.No:
                return
    
        if not os.path.exists(os.path.dirname(file_path)):
            os.makedirs(os.path.dirname(file_path))

        manager = ExportManager()

        settings_dict = {
            "paper_format": self.dlg.comboBox_PapierFormaat.currentText(),
            "file_format": self.dlg.comboBox_BestandsFormaat.currentText().lower(),
            "include_north": self.dlg.checkBox_Noordpijl.isChecked(),
            "include_legend": self.dlg.checkBox_Legenda.isChecked(),
            "include_scale": self.dlg.checkBox_Schaalbalk.isChecked(),
            "canvas": self.iface.mapCanvas()
        }
        layout = manager.build_layout(settings_dict)

        success = manager.export(layout, file_path)
        if success:
            self.log(f"Kaart succesvol geëxporteerd naar {file_path}")
            QMessageBox.information(
                self.dlg,
                "Export succesvol",
                f"De kaart is succesvol geëxporteerd naar {file_path}.",
            )
        else:
            self.log(f"Fout bij het exporteren van de kaart naar {file_path}", 1)
            QMessageBox.critical(
                self.dlg,
                "Export mislukt",
                f"Het exporteren van de kaart naar {file_path} is mislukt.",
            )

    def generate_export_path(self):
        map_name = self.dlg.lineEdit_MapName.text()
        if not map_name:
            return

        file_format = self.dlg.comboBox_BestandsFormaat.currentText()
        return os.path.join(self.working_dir, "export", f"{map_name}.{file_format.lower()}")
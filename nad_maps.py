# -*- coding: utf-8 -*-
"""
/***************************************************************************
 NADMaps
                                 A QGIS plugin
 Centrale plek om handige kaarten voor waterketen en rioolbeheer te vinden en snel in te laden.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-01-09
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Netwerk Waterketen Delfland
        email                : dataplatform@waterketendelfland.nl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# General packages
import os.path
import json
import re
import urllib.request, urllib.parse, urllib.error

# PyQGIS packages
from qgis.PyQt.QtCore import (
    Qt, QSettings,
    QTranslator,
    QCoreApplication,
    QSortFilterProxyModel,
    QRegularExpression,
    QTimer
)
from qgis.PyQt.QtGui import QIcon, QStandardItemModel, QStandardItem, QColor
from qgis.PyQt import QtWidgets
from qgis.gui import QgsVertexMarker
# from qgis.PyQt import QtCore, QtGui, 
# https://api.qgis.org/api/group__core.html
from qgis.core import (
    Qgis,
    QgsProject,
    QgsLayerTreeLayer,
    QgsRasterLayer,
    QgsMessageLog,
    QgsVectorLayer,
    QgsVectorTileLayer,
    QgsCoordinateReferenceSystem,
    QgsRectangle,
    QgsCoordinateTransform,
    QgsGeometry,
    QgsWkbTypes,
    QgsPointXY,
    QgsMapLayer
)
from qgis.PyQt.QtWidgets import (
    QSizePolicy,
    QAction,
    QAbstractItemView,
    QPushButton,
    QDialog,
    QGridLayout,
    QDialogButtonBox,
    QCompleter,
)

# Initialize Qt resources from file resources.py
from .resources import *
# Import code for the search and zoom function
from .lib.locatieserver import (
    suggest_query,
    TypeFilter,
    LsType,
    lookup_object,
    get_lookup_object_url,
    Projection,
)
# Import the code for the dialog
from .nad_maps_dialog import NADMapsDialog
from .lib.constants import PLUGIN_NAME, PLUGIN_ID





class NADMaps(object):
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        self.dlg = NADMapsDialog(parent=self.iface.mainWindow())
        self.dlg.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Maximum)
        # initialize locale (find language of the user)
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'NADMaps_{}.qm'.format(locale))

        thema_filename = "default.json"
        self.thema_path = os.path.join(
            self.plugin_dir,
            "resources\\themas",
            thema_filename)

        self.styling_path = os.path.join(
            self.plugin_dir,
            "resources\\styling")

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&NAD Waterketen Kaarten')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        self.current_layer = None

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        self.run_icon = QIcon(
            os.path.join(self.plugin_dir, "resources", "nad.png")
        )

        self.add_action(
            icon_path = self.run_icon,
            text=PLUGIN_NAME,
            callback=self.run,
            parent=self.iface.mainWindow())

        # Set default layer loading behaviour
        self.service_type_mapping = {
            "wms": "WMS",
            "wmts": "WMTS",
            "wfs": "WFS",
            "wcs": "WCS",
            "api features": "OGC API - Features",
            "api tiles": "OGC API - Tiles",
        }
        # Set default layer loading behaviour
        self.default_tree_locations = {
            "wms": "top",
            "wmts": "bottom",
            "wfs": "top",
            "wcs": "top",
            "api features": "top",
            "api tiles": "bottom",
        }
        self.layer_type_mapping = {
            0: "VectorLayer",
            1: "RasterLayer",
            2: "PluginLayer",
            3: "MeshLayer",
            4: "VectorTileLayer",
            5: "AnnotationLayer",
            6: "PointCloudLayer",
            7: "GroupLayer"
        }
        # will be set True in run()
        self.maps_loaded = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&NAD Waterketen Kaarten'),
                action)
            self.iface.removeToolBarIcon(action)

    def add_source_row(self, serviceLayer):
        # you can attache different "data's" to to an QStandarditem
        # default one is the visible one:
        stype = (
            self.service_type_mapping[serviceLayer["service_type"]]
            if serviceLayer["service_type"] in self.service_type_mapping
            else serviceLayer["service_type"].upper()
        )
        itemType = QStandardItem(str(stype))
        # userrole is a free form one:
        # only attach the data to the first item
        # service layer = a dict/object with all props of the layer
        # https://www.riverbankcomputing.com/static/Docs/PyQt4/qt.html#ItemDataRole-enum
        itemType.setData(serviceLayer, Qt.ItemDataRole.UserRole)
        itemType.setToolTip(f'{stype} - {serviceLayer["title"]}')
        # only wms services have styles (sometimes)
        layername = serviceLayer["title"]
        styles_string = ""
        if "styles" in serviceLayer:
            styles_string = " ".join(
                [" ".join(x.values()) for x in serviceLayer["styles"]]
            )

        itemLayername = QStandardItem(str(serviceLayer["title"]))
        itemLayername.setToolTip(f'{stype} - {serviceLayer["service_title"]}')
        # itemFilter is the item used to search filter in. That is why layername is a combi of layername + filter here
        itemFilter = QStandardItem(
            f'{serviceLayer["service_type"]} {layername} {serviceLayer["service_title"]} {serviceLayer["service_abstract"]} {styles_string}'
        )
        itemServicetitle = QStandardItem(str(serviceLayer["service_title"]))
        itemServicetitle.setToolTip(f'{stype} - {serviceLayer["title"]}')
        self.sourceModel.appendRow(
            [itemLayername, itemType, itemServicetitle, itemFilter]
        )


    def load_layer(self, tree_location=None):
        """Adds a QgsLayer to the project and layer tree.
        tree_location can be 'default', 'top', 'bottom'
        """
        self.log(f"Inside function load_layer")
        if self.current_layer is None:
            self.log("self.current_layer is None")
            return

        servicetype = self.current_layer["service_type"]
        if tree_location is None:
            tree_location = self.default_tree_locations[servicetype]
        
        new_layer = self.create_new_layer()
        if new_layer is None:
            return
        
        if tree_location not in ["default", "top", "bottom"]:
            # TODO: proper error handling
            return
        if tree_location == "default":
            QgsProject.instance().addMapLayer(new_layer, True)
            return
        QgsProject.instance().addMapLayer(new_layer, False)
        new_layer_tree_layer = QgsLayerTreeLayer(new_layer)
        layer_tree = self.iface.layerTreeCanvasBridge().rootGroup()
        if tree_location == "top":
            layer_tree.insertChildNode(0, new_layer_tree_layer)
        if tree_location == "bottom":
            layer_tree.insertChildNode(-1, new_layer_tree_layer)

    
    def create_new_layer(self):
        servicetype = self.current_layer["service_type"]
        title = self.current_layer["title"]
        layername = self.current_layer["name"]
        url = self.current_layer["service_url"]

        if servicetype == "wms":
            return self.create_wms_layer(layername, title, url)
        elif servicetype == "wmts":
            return self.create_wmts_layer(layername, title, url, servicetype)
        elif servicetype == "wfs":
            layer = self.create_wfs_layer(layername, title, url)
            self.log(f"layer data type is {str(type(layer))}")
            # styling = self.current_layer["styling"]
            # self.log(f"styling is {str(styling)}")
            # if styling and styling != "":
            #     # something
            #     self.log(f"here")
            #     self.load_qml_style(layer, styling)
            # else:
            #     self.log(f"here")
            #     return

            return layer
        elif servicetype == "wcs":
            return self.create_wcs_layer(layername, title, url)
        elif servicetype == "api features":
            return self.create_oaf_layer(layername, title, url)
        elif servicetype == "api tiles":
            return self.create_oat_layer(title, url)
        else:
            self.show_warning(
                f"""Sorry, dit type laag: '{servicetype.upper()}'
                kan niet worden geladen door de plugin of door QGIS.
                Is het niet beschikbaar als wms, wmts, wfs, api features of api tiles (vectortile)?
                """
            )
            return

    def create_wfs_layer(self, layername, title, url):
        uri = f" pagingEnabled='true' restrictToRequestBBOX='1' srsname='EPSG:28992' typename='{layername}' url='{url}' version='2.0.0'"
        return QgsVectorLayer(uri, title, "wfs")

    def create_wms_layer(self, layername, title, url):
        imgformat = self.current_layer["imgformats"].split(",")[0]
        crs = "EPSG:28992"

        selected_style_name = "default"
        uri = f"crs={crs}&layers={layername}&styles={selected_style_name}&format={imgformat}&url={url}"
        # crs=EPSG:28992&layers=top25raster&styles=default&format=image/png&url=https://service.pdok.nl/brt/topraster/wms/v1_0?request=GetCapabilities&service=WMS
        return QgsRasterLayer(uri, title, "wms")

    def create_wcs_layer(self, layername, title, url):
        # HACK to get WCS to work:
        # 1) fixed format to "GEOTIFF"
        # 2) remove the '?request=getcapabiliteis....' part from the url, unknown why this is required compared to wms/wfs
        # better approach would be to add the supported format(s) to the layers-pdok.json file and use that - this should be the approach when more
        # WCS services will be published by PDOK (currently it is only the AHN WCS)
        format = "GEOTIFF"
        uri = f"cache=AlwaysNetwork&crs=EPSG:28992&format={format}&identifier={layername}&url={url.split('?')[0]}"
        return QgsRasterLayer(uri, title, "wcs")

    def build_tileset_url(self, url, tileset_id, for_request):
        url_template = url + "/tiles/" + tileset_id
        if for_request:
            return url_template + "/%7Bz%7D/%7By%7D/%7Bx%7D?f%3Dmvt"
        return url_template + "/{z}/{y}/{x}?f=mvt"

    def create_oat_layer(self, title, url):
        # CRS does not work as expected in qgis/gdal. We can set a crs (non-webmercator), but it is rendered incorrectly.
        crs = "EPSG:28992"
        used_tileset = [
            tileset
            for tileset in self.current_layer["tiles"][0]["tilesets"]
            if tileset["tileset_crs"].endswith(crs.split(":")[1])
        ][0]

        # Style toevoegen in laag vanuit ui
        # selected_style = self.get_selected_style()
        # selected_style_url = "bgt_standaardvisualisatie__netherlandsrdnewquad"
        name = self.current_layer["styles"][0]["name"]
        self.log(f"name is {name}")
        self.log(f"old title is {title}")
        title += f" [{name}]"
        self.log(f"new title is {title}")
        selected_style_url = self.current_layer["styles"][0]["url"]
        self.log(f"selected_style_url is {selected_style_url}")

        # if selected_style is not None:
        #     selected_style_url = selected_style["url"]
        #     title += f" [{selected_style['name']}]"

        url_template = self.build_tileset_url(url, used_tileset["tileset_id"], True)
        self.log(f"url_template is {url_template}")
        
        maxz_coord = used_tileset["tileset_max_zoomlevel"]

        # Although the vector tiles are only rendered for a specific zoom-level @PDOK (see maxz_coord),
        # we need to set the minimum z value to 0, which gives better performance, see https://github.com/qgis/QGIS/issues/54312
        minz_coord = 0

        type = "xyz"
        uri = f"styleUrl={selected_style_url}&url={url_template}&type={type}&zmax={maxz_coord}&zmin={minz_coord}&http-header:referer="
        tile_layer = QgsVectorTileLayer(uri, title)
        # styleUrl=https://api.pdok.nl/lv/bag/ogc/v1_0/styles/bag_standaardvisualisatie__netherlandsrdnewquad?f=mapbox&url=https://api.pdok.nl/lv/bag/ogc/v1_0/tiles/WebMercatorQuad/%7Bz%7D/%7By%7D/%7Bx%7D?f%3Dmvt&type=xyz&zmax=17&zmin=0&http-header:referer=
        # Set the VT layer CRS and load the styleUrl
        tile_layer.setCrs(srs=QgsCoordinateReferenceSystem(crs))
        tile_layer.loadDefaultStyle()
        return tile_layer

    def create_wmts_layer(self, layername, title, url, servicetype):
        if Qgis.QGIS_VERSION_INT < 10900:
            self.show_warning(
                f"""Sorry, dit type layer: '{servicetype.upper()}'
                kan niet worden geladen in deze versie van QGIS.
                Misschien kunt u QGIS 2.0 installeren (die kan het WEL)?
                Of is de laag niet ook beschikbaar als wms of wfs?"""
            )
            return None
        url = self.quote_wmts_url(url)
        imgformat = self.current_layer["imgformats"].split(",")[0]
        # some fiddling with tilematrixset names and crs's (which sometimes are the same, but other times are not)
        tilematrixset = self.current_layer["tilematrixsets"]
        if tilematrixset.startswith("EPSG:"):
            crs = tilematrixset
            i = crs.find(":", 5)
            if i > -1:
                crs = crs[:i]
        elif tilematrixset.startswith("OGC:1.0"):
            crs = "EPSG:3857"
        else:
            # non PDOK services do not have a strict tilematrixset naming based on crs...
            crs = self.current_layer["crs"]

        uri = f"crs={crs}&tileMatrixSet={tilematrixset}&layers={layername}&styles=default&format={imgformat}&url={url}"
        return QgsRasterLayer(
            uri, title, "wms"
        )  # LET OP: `wms` is correct, zie ook quote_wmts_url

    def quote_wmts_url(self, url):
        """
        Quoten wmts url is nodig omdat qgis de query param `SERVICE=WMS` erachter plakt als je de wmts url niet quote.
        Dit vermoedelijk omdat de wmts laag wordt toegevoegd mbv de wms provider: `return QgsRasterLayer(uri, title, "wms")`.
        Wat op basis van de documentatie wel de manier is om een wmts laag toe te voegen.
        """
        parse_result = urllib.parse.urlparse(url)
        location = f"{parse_result.scheme}://{parse_result.netloc}/{parse_result.path}"
        query = parse_result.query
        query_escaped_quoted = urllib.parse.quote_plus(query)
        url = f"{location}?{query_escaped_quoted}"
        return url


#########################################################################################
##############  Zoom function to go to selected locations ####################
#########################################################################################

    def zoom_to(self):
        """Zoom to desired location"""
        self.log("inside zoom_to function")



#########################################################################################
##############  Manage thema sets (a list of one or more map layers) ####################
#########################################################################################

    # TODO: First implement the UI
    def delete_thema(self):
        """Delete an existing thema (only user defined themas should be deleted)"""
        self.log("Starting the delete_thema function")

        # Find the thema name to be deleted
        thema_name = self.current_thema["thema_name"]
        self.log(f"Thema to be deleted is {thema_name}")

        with open(self.thema_path, "r", encoding="utf-8") as f:
            jsondata = json.load(f)

        # Iterate through the json list and remove the object with the selected name
        jsondata = [obj for obj in jsondata if obj["thema_name"] != thema_name]
        
        with open(self.thema_path, "w", encoding="utf-8") as feedsjson:
            json.dump(jsondata, feedsjson, indent='\t')

        self.update_thema_list()
        self.log("Finished the delete_thema function")


    def save_thema(self, all: bool):
        """Save a collection of layers in order to later quickly load them"""
        self.log("Starting the save_thema function")
        self.log(f"Save all? {all}")
        # TODO: does this work properly?
        if not os.path.isfile(self.thema_path):
            with open(self.thema_path, "w", encoding="utf-8") as f:
                json.dump([], f)
        
        # Collect a json string with a thema_name and a list of layer names
        thema_name = self.dlg.saveThemaLineEdit.text()
        self.log(f"Thema name given is {thema_name}")

        string = "{\"thema_name\": \"" + thema_name + "\", "
        string = string + "\"layers\": ["

        # https://doc.qt.io/qt-6/qabstractitemmodel.html#details # documentation p1
        # https://doc.qt.io/qt-6/qt.html#ItemDataRole-enum # documentation p2
        if all == False:
            selected_layers = self.selected_active_layers
        else:
            selectedIndexes = self.dlg.activeMapListView.selectedIndexes()
            selected_layers = set(index.siblingAtColumn(0) for index in selectedIndexes)

        self.log(f"List of active selected layers is {selected_layers}, with length is {len(selected_layers)}")
        for i, layer in enumerate(selected_layers):
            self.log(layer.name())
            string = string + "\"" + layer.name() + "\""
            if i == len(selected_layers) - 1:
                self.log("end")
                string = string + "]"
            else:
                self.log("going")
                string = string + ", "
        string = string + "}"
        self.log(string)

        data = json.loads(string)
        # https://stackoverflow.com/questions/12994442/how-to-append-data-to-a-json-file
        with open(self.thema_path, "r", encoding="utf-8") as feedsjson:
            feeds = json.load(feedsjson)
        with open(self.thema_path, "w", encoding="utf-8") as feedsjson:
            feeds.append(data)
            json.dump(feeds, feedsjson, indent='\t')
        
        self.update_thema_list()
        self.dlg.saveThemaLineEdit.clear()
        self.log("Finished the save_thema function")

    def update_thema_list(self):
        """Add a thema to the thema model"""
        self.themaModel.clear()
        
        self.themas = []
        with open(self.thema_path, "r", encoding="utf-8") as f:
            self.themas.extend(json.load(f))
        
        for thema in self.themas:
            itemThema = QStandardItem(str(thema["thema_name"]))
            itemSource = QStandardItem(str("Plugin"))
            itemFilter = QStandardItem(f'{thema["thema_name"]} {thema["layers"]}')
            # https://doc.qt.io/qt-6/qstandarditem.html#setData
            itemThema.setData(thema, Qt.ItemDataRole.UserRole)
            self.themaModel.appendRow(
                [itemThema, itemSource, itemFilter]
            )
            
        self.themaModel.setHeaderData(1, Qt.Orientation.Horizontal, "Bron")
        self.themaModel.setHeaderData(0, Qt.Orientation.Horizontal, "Thema")
        self.themaModel.horizontalHeaderItem(1).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.themaModel.horizontalHeaderItem(0).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.dlg.themaView.horizontalHeader().setStretchLastSection(True)
        self.dlg.themaView.hideColumn(2)
        self.dlg.themaView.setColumnWidth(
            0, 300
        )  # set name to 300px (there are some huge layernames)
        self.dlg.themaView.horizontalHeader().setStretchLastSection(True)


#########################################################################################
##############  Updating the layers that are part of a thema set ########################
#########################################################################################

    def show_thema_layers(self, selectedIndexes):
        """Show the layers that are part of a thema"""
        self.log(f"show_thema_layers: len(selectedIndexes) is {str(len(selectedIndexes))}")
        if len(selectedIndexes) == 0:
            self.current_layer = None
            return
        
        self.current_thema = self.dlg.themaView.selectedIndexes()[0].data(
            Qt.ItemDataRole.UserRole
        )

        layers = self.current_thema["layers"]
        layer_path = os.path.join(self.plugin_dir, "resources", "layers-nad.json")
        self.thema_layers = []
        for layer in layers:
            with open(layer_path, "r", encoding="utf-8") as f:
                all_layers = json.load(f)
                for i, r in enumerate(all_layers):
                    title = all_layers[i]["title"]
                    if layer == title:
                        self.thema_layers.append(all_layers[i])
        self.update_thema_layers()
        self.log("Finished the show_thema_layers function")


    def load_thema_layers(self):
        """Load the layers of this thema to the canvas"""
        self.log(f"load_thema_layers: current_thema is {self.current_thema["thema_name"]}")
        thema_layers = self.thema_layers
        for layer in thema_layers:
            name = layer["name"]
            self.log(name)
            self.current_layer = layer
            # self.load_layer(None)
            self.load_layer(None)
        self.iface.layerTreeView().collapseAllNodes()
        self.update_active_map_list()
        self.log("Finished the load_thema_layers function")


    def update_thema_layers(self):
        """Update the list of layers contained with this thema"""
        thema_layers = self.thema_layers
        
        self.themaMapModel.clear()

        for layer in thema_layers:
            itemLayername = QStandardItem(str(layer["title"]))
            stype = (
                self.service_type_mapping[layer["service_type"]]
                if layer["service_type"] in self.service_type_mapping
                else layer["service_type"].upper()
            )
            itemType = QStandardItem(str(stype))
            itemServicetitle = QStandardItem(str(layer["service_title"]))
            self.themaMapModel.appendRow(
                [itemLayername, itemType, itemServicetitle]
            )
            
        self.themaMapModel.setHeaderData(2, Qt.Orientation.Horizontal, "Service")
        self.themaMapModel.setHeaderData(1, Qt.Orientation.Horizontal, "Type")
        self.themaMapModel.setHeaderData(0, Qt.Orientation.Horizontal, "Laagnaam")
        self.themaMapModel.horizontalHeaderItem(2).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.themaMapModel.horizontalHeaderItem(1).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.themaMapModel.horizontalHeaderItem(0).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.dlg.themaMapListView.horizontalHeader().setStretchLastSection(True)
        self.dlg.themaMapListView.hideColumn(3)
        
        self.dlg.themaMapListView.setColumnWidth(
            0, 200
        )  # set name to 300px (there are some huge layernames)
        self.dlg.themaMapListView.horizontalHeader().setStretchLastSection(True)


#########################################################################################
############################  Show a regular layer ########################
#########################################################################################

    def get_current_layer(self, selectedIndexes):
        self.log(f"get_current_layer: len(selectedIndexes) is {str(len(selectedIndexes))}")
        if len(selectedIndexes) == 0:
            self.current_layer = None
            return

        self.dlg.mapListView.scrollTo(self.dlg.mapListView.selectedIndexes()[0])
        # itemType holds the data (== column 1) hence self.dlg.mapListView.selectedIndexes()[1], see itemType.setData(serviceLayer, Qt.ItemDataRole.UserRole)
        self.current_layer = self.dlg.mapListView.selectedIndexes()[1].data(
            Qt.ItemDataRole.UserRole
        )

#########################################################################################
######################  Show current loaded layers on the canvas ########################
#########################################################################################


    def load_qml_style(self, layer, styling):
        if not styling:
            return
        else:
            path = self.styling_path + f"{layer.name()}/{styling}.qml"
            self.log(path)
            layer.loadNamedStyle(path)
            layer.triggerRepaint()
            # print(layer.name())
        # self.configure_dropdown()
        # vlayer.renderer().symbol().setSize(6)
        # vlayer.triggerRepaint()


    def save_styling(self, layer, styling):
        """Save the styling of the current layer to a qml file"""
        # https://gis.stackexchange.com/search?q=%5Bqml%5Dsave
        # very old blog: https://snorfalorpagus.net/blog/2014/03/04/symbology-of-vector-layers-in-qgis-python-plugins/
        # https://anitagraser.com/pyqgis-101-introduction-to-qgis-python-programming-for-non-programmers/pyqgis-101-styling-vector-layers/
        # https://opensourceoptions.com/loading-and-symbolizing-raster-layers/

        path = self.styling_path + f"{layer.name()}/{styling}.qml"
        self.log(path)
        if layer.type() == QgsMapLayer.VectorLayer:
            layer.saveNamedStyle(path)
            # https://qgis.org/pyqgis/master/core/QgsMapLayer.html#qgis.core.QgsMapLayer.saveNamedStyle
            # lyr.saveNamedStyle(path, categories = QgsMapLayer.Symbology | QgsMapLayer.Labeling | QgsMapLayer.Forms)


    def update_active_map_list(self):
        """Update the table with active layers in the project"""
        self.log(f"update_active_map_list function started")        
        self.mapsModel.clear()

        # self.iface.layerTreeView()
        layers = QgsProject.instance().mapLayers().values()
        self.log(f"Number of layers: {len(layers)}")
        if len(layers) < 1:
            itemLayername = QStandardItem(str(""))
            itemType = QStandardItem(str(""))
            itemStylingTitle = QStandardItem(str(""))
            itemSource = QStandardItem(str(""))
            self.mapsModel.appendRow(
                [itemLayername, itemType, itemStylingTitle, itemSource]
            )
        else:
            for i, layer in enumerate(layers):
                self.log(f"Layer {layer} has name: {layer.name()} of type {layer.type()} with source {layer.source()}")
                layer_type = self.layer_type_mapping[layer.type()]
                self.log(f"layer is {layer}")
                # l is the same value as QgsVectorLayer(uri, title, "wfs"), e.g. <QgsVectorLayer: 'Riolering WFS: Leiding' (WFS)>

                itemLayername = QStandardItem(str(layer.name()))
                itemType = QStandardItem(str(layer_type))
                styling = "default"
                # if l.type() == 0:
                #     self.log(str(styling))
                #     styling = l.writeStyle()
                #     self.log(str(styling))
                itemStylingTitle = QStandardItem(str(styling))
                itemSource = QStandardItem(str(layer.source()))
                itemSource.setToolTip(str(layer.source()))
                self.mapsModel.appendRow(
                    [itemLayername, itemType, itemStylingTitle, itemSource]
                )
                itemLayername.setData(layer, Qt.ItemDataRole.UserRole)

        self.mapsModel.setHeaderData(3, Qt.Orientation.Horizontal, "Bron")
        self.mapsModel.setHeaderData(2, Qt.Orientation.Horizontal, "Styling")
        self.mapsModel.setHeaderData(1, Qt.Orientation.Horizontal, "Type")
        self.mapsModel.setHeaderData(0, Qt.Orientation.Horizontal, "Laagnaam")
        self.mapsModel.horizontalHeaderItem(3).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.mapsModel.horizontalHeaderItem(2).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.mapsModel.horizontalHeaderItem(1).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.mapsModel.horizontalHeaderItem(0).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.dlg.activeMapListView.horizontalHeader().setStretchLastSection(True)
        # self.dlg.activeMapListView.hideColumn(3)
        
        self.dlg.activeMapListView.setColumnWidth(
            0, 150
        )  # set name to 300px (there are some huge layernames)
        self.dlg.activeMapListView.horizontalHeader().setStretchLastSection(True)



# OGC API - Tiles
# Layer 0 has name: Bestuurlijke Gebieden - Tiles [Bestuurlijke Gebieden Standaardvisualisatie (NetherlandsRDNewQuad)] of type 4 with source styleUrl=https://api.pdok.nl/kadaster/bestuurlijkegebieden/ogc/v1_0/styles/bestuurlijkegebieden_standaardvisualisatie__netherlandsrdnewquad?f=mapbox&url=https://api.pdok.nl/kadaster/bestuurlijkegebieden/ogc/v1_0/tiles/WebMercatorQuad/%7Bz%7D/%7By%7D/%7Bx%7D?f%3Dmvt&type=xyz&zmax=17&zmin=0&http-header:referer=
# <QgsVectorTileLayer: 'Bestuurlijke Gebieden - Tiles [Bestuurlijke Gebieden Standaardvisualisatie (NetherlandsRDNewQuad)]'>

# WMTS
# Layer 1 has name: Luchtfoto Actueel Ortho 8cm RGB of type 1 with source crs=EPSG:28992&tileMatrixSet=EPSG:28992&layers=Actueel_orthoHR&styles=default&format=image/jpeg&url=https://service.pdok.nl//hwh/luchtfotorgb/wmts/v1_0?request%3DGetCapabilities%26service%3DWMTS
# <QgsRasterLayer: 'Luchtfoto Actueel Ortho 8cm RGB' (wms)>

# WFS
# Layer 2 has name: Riolering WFS: Put of type 0 with source  pagingEnabled='true' restrictToRequestBBOX='1' srsname='EPSG:28992' typename='beheerstedelijkwater:BeheerPut' url='https://service.pdok.nl/rioned/beheerstedelijkwater/wfs/v1_0?request=GetCapabilities&service=WFS' version='2.0.0'
# <QgsVectorLayer: 'Riolering WFS: Put' (WFS)>

# WMS
# Layer 4 has name: Riolering WMS: Put of type 1 with source crs=EPSG:28992&layers=BeheerPut&styles=default&format=image/png&url=https://service.pdok.nl/rioned/beheerstedelijkwater/wms/v1_0?request=GetCapabilities&service=WMS
# <QgsRasterLayer: 'Riolering WMS: Put' (wms)>

# OGC API - Features
# Layer 5 has name: Wegdeel (WGD) of type 0 with source  pagingEnabled='true' restrictToRequestBBOX='1' preferCoordinatesForWfsT11='false' typename='wegdeel' url='https://api.pdok.nl/lv/bgt/ogc/v1'
# <QgsVectorLayer: 'Wegdeel (WGD)' (OAPIF)>

# WMTS
# Layer 6 has name: standaard of type 1 with source crs=EPSG:28992&tileMatrixSet=EPSG:28992&layers=standaard&styles=default&format=image/png&url=https://service.pdok.nl//brt/achtergrondkaart/wmts/v2_0?request%3DGetCapabilities%26service%3DWMTS
# <QgsRasterLayer: 'standaard' (wms)>

# WCS
# Layer 0 has name: Digital Surface Model (DSM) 0.5m of type 1 with source cache=AlwaysNetwork&crs=EPSG:28992&format=GEOTIFF&identifier=dsm_05m&url=https://service.pdok.nl/rws/ahn/wcs/v1_0
# <QgsRasterLayer: 'Digital Surface Model (DSM) 0.5m' (wcs)>

    def get_selected_active_layers(self):
        selectedIndexes = self.dlg.activeMapListView.selectedIndexes()
        first_index_list = set(index.siblingAtColumn(0) for index in selectedIndexes)
        nr_of_selected_rows = len(set(index.row() for index in selectedIndexes))
        self.log(f"get_active_layer: nr of rows selected is {nr_of_selected_rows}")

        # enable or disable the styling-functions
        if nr_of_selected_rows == 1:
            self.dlg.stylingGroupBox.setEnabled(True)
            self.dlg.stylingGroupBox.setToolTip("")
            self.dlg.saveThemaButton.setEnabled(True)
            self.dlg.saveThemaButton.setToolTip("")
        elif nr_of_selected_rows > 1:
            self.dlg.stylingGroupBox.setEnabled(False)
            self.dlg.stylingGroupBox.setToolTip("Selecteer maar één laag om de styling aan te passen")
            self.dlg.saveThemaButton.setEnabled(True)
            self.dlg.saveThemaButton.setToolTip("")
        elif nr_of_selected_rows == 0:
            self.dlg.stylingGroupBox.setEnabled(False)
            self.dlg.stylingGroupBox.setToolTip("Selecteer maar één laag om de styling aan te passen")
            self.dlg.saveThemaButton.setEnabled(False)
            self.dlg.saveThemaButton.setToolTip("Geen lagen geselecteerd")
            self.selected_active_layers = None
            return

        self.selected_active_layers = []
        first_index_list = set(index.siblingAtColumn(0) for index in selectedIndexes)
        for index in first_index_list:
            self.log(f"active_layer is {index}, at row {index.row()} and column {index.column()}")
            active_layer = index.data(
                    Qt.ItemDataRole.UserRole
                )
            # self.log(f"active_layer is {active_layer}")
            # self.log(f"active_layer name is {active_layer.name()}")
            # self.log(f"active_layer source is {active_layer.source()}")
            self.selected_active_layers.append(active_layer)





#########################################################################################
####################  Run main script to initiate when NAD button is pressed ############
#########################################################################################

    def run(self, hiddenDialog=False):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.maps_loaded == False:
            self.maps_loaded = True
            # general functions
            # self.dlg.zoomComboBox.addItems(self.municipality_list)
            self.dlg.zoomButton.clicked.connect(lambda: self.zoom_to())
            self.dlg.searchLineEdit.textChanged.connect(self.filter_layers)

            self.timer_toolbar_search = QTimer()
            self.timer_toolbar_search.setSingleShot(True)
            self.timer_toolbar_search.setInterval(200)
            self.timer_toolbar_search.timeout.connect(self.toolbar_search_get_suggestions)
            self.dlg.zoomLineEdit.textEdited.connect(
                lambda: self.timer_toolbar_search.start()
            )
            
            self.logModel = QStandardItemModel()
            self.dlg.logView.setModel(self.logModel)
            self.dlg.logView.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
            self.log('started logging')
            # active maps tab
            
            ### maps list
            self.mapsModel = QStandardItemModel()
            self.styleFilterMaps = QSortFilterProxyModel()
            self.styleFilterMaps.setSourceModel(self.mapsModel)
            self.styleFilterMaps.setFilterKeyColumn(2)

            self.proxyModelMaps = QSortFilterProxyModel()
            self.proxyModelMaps.setSourceModel(self.styleFilterMaps)
            self.proxyModelMaps.setFilterKeyColumn(1)

            self.dlg.activeMapListView.setModel(self.mapsModel)
            self.dlg.activeMapListView.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
            
            # create a list of existing themas
            self.update_active_map_list()
            
            self.dlg.activeMapListView.selectionModel().selectionChanged.connect(
                self.get_selected_active_layers
            )

            # TODO: make these functions
            self.dlg.loadStyleButton.clicked.connect(lambda: self.load_styling())
            self.dlg.removeStyleButton.clicked.connect(lambda: self.delete_styling())
            self.dlg.saveStyleButton.clicked.connect(lambda: self.save_styling())

            self.dlg.saveThemaButton.clicked.connect(lambda: self.save_thema(False))
            self.dlg.saveAllThemaButton.clicked.connect(lambda: self.save_thema(True))

            # thema tab
            
            ### thema list
            self.themaModel = QStandardItemModel()
            self.styleFilterThema = QSortFilterProxyModel()
            self.styleFilterThema.setSourceModel(self.themaModel)
            self.styleFilterThema.setFilterKeyColumn(2)

            self.proxyModelThema = QSortFilterProxyModel()
            self.proxyModelThema.setSourceModel(self.styleFilterThema)
            self.proxyModelThema.setFilterKeyColumn(1)

            self.dlg.themaView.setModel(self.proxyModelThema)
            self.dlg.themaView.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
            
            # create a list of existing themas
            self.update_thema_list()

            # update the display with a list of map layers within the selected thema
            self.dlg.themaView.selectionModel().selectionChanged.connect(
                self.show_thema_layers
            )
            ### thema layers list
            self.themaMapModel = QStandardItemModel()
            self.styleFilterThemaMaps = QSortFilterProxyModel()
            self.styleFilterThemaMaps.setSourceModel(self.themaMapModel)
            self.styleFilterThemaMaps.setFilterKeyColumn(4)
            
            self.proxyModelThemaMaps = QSortFilterProxyModel()
            self.proxyModelThemaMaps.setSourceModel(self.styleFilterThemaMaps)
            self.proxyModelThemaMaps.setFilterKeyColumn(3)

            self.dlg.themaMapListView.setModel(self.proxyModelThemaMaps)
            self.dlg.themaMapListView.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)

            self.dlg.themaView.selectionModel().select(
                self.themaModel.index(0,0), QtCore.QItemSelectionModel.Select | QtCore.QItemSelectionModel.Rows
            )
            self.dlg.themaView.doubleClicked.connect(
                lambda: self.load_thema_layers()
            )  # Using lambda here to prevent sending signal parameters to the loadService() function

            self.dlg.deleteThemaButton.clicked.connect(lambda: self.delete_thema())
            
            # layers tab
            self.layers_nad = []
            layer_path = os.path.join(self.plugin_dir, "resources", "layers-nad.json")
            with open(layer_path, "r", encoding="utf-8") as f:
                self.layers_nad.extend(json.load(f))

            self.sourceModel = QStandardItemModel()

            self.styleFilter = QSortFilterProxyModel()
            self.styleFilter.setSourceModel(self.sourceModel)
            self.styleFilter.setFilterKeyColumn(4)

            self.proxyModel = QSortFilterProxyModel()
            self.proxyModel.setSourceModel(self.styleFilter)
            self.proxyModel.setFilterKeyColumn(3)

            self.dlg.mapListView.setModel(self.proxyModel)
            self.dlg.mapListView.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)

            for layer in self.layers_nad:
                if isinstance(layer["name"], str):
                    self.add_source_row(layer)

            self.dlg.mapListView.selectionModel().selectionChanged.connect(
                self.get_current_layer
            )
            self.dlg.mapListView.doubleClicked.connect(
                lambda: self.load_layer(None)
            )  # Using lambda here to prevent sending signal parameters to the loadService() function
            
            self.dlg.stylingGroupBox.setEnabled(False)
            self.dlg.stylingGroupBox.setToolTip("Selecteer maar één laag om de styling aan te passen")
            self.dlg.saveThemaButton.setEnabled(False)
            self.dlg.saveThemaButton.setToolTip("Geen lagen geselecteerd")
            self.dlg.themaView.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            self.dlg.mapListView.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            self.dlg.mapListView.verticalHeader().setSectionsClickable(False)
            self.dlg.mapListView.horizontalHeader().setSectionsClickable(False)
            # hide itemFilter column:
            self.dlg.mapListView.hideColumn(3)

        self.logModel.setHeaderData(0, Qt.Orientation.Horizontal, "Log bericht")
        self.logModel.horizontalHeaderItem(0).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.dlg.logView.horizontalHeader().setStretchLastSection(True)
        
        self.sourceModel.setHeaderData(2, Qt.Orientation.Horizontal, "Service")
        self.sourceModel.setHeaderData(1, Qt.Orientation.Horizontal, "Type")
        self.sourceModel.setHeaderData(0, Qt.Orientation.Horizontal, "Laagnaam")
        self.sourceModel.horizontalHeaderItem(2).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.sourceModel.horizontalHeaderItem(1).setTextAlignment(Qt.AlignmentFlag.AlignLeft)
        self.sourceModel.horizontalHeaderItem(0).setTextAlignment(Qt.AlignmentFlag.AlignLeft)

        self.dlg.mapListView.setColumnWidth(
            0, 200
        )  # set name to 300px (there are some huge layernames)
        self.dlg.mapListView.horizontalHeader().setStretchLastSection(True)
        # self.dlg.mapListView.resizeColumnsToContents()
        # show the dialog
        if not hiddenDialog:
            self.dlg.show()
        
        self.dlg.tabWidget.currentChanged.connect(self.active_buttons)

        self.dlg.load_button.clicked.connect(lambda: self.load_button_pressed(False))
        self.dlg.load_close_button.clicked.connect(lambda: self.load_button_pressed(True))
        self.dlg.close_button.clicked.connect(lambda: self.dlg.hide())



        

#########################################################################################
####################  Save the current canvas function ############
#########################################################################################

    # TODO: function to export current canvas as pdf or image
    def save_canvas(self):
        """Export the current map to pdf or png, including a north-arrow"""
        # qgis.utils.iface.mapCanvas().saveAsImage('test.png', None, 'PNG') 


#########################################################################################
####################  Search for locations for the zoom functionality ###################
#########################################################################################

    def create_type_filter(self):
        """
        This creates a TypeFilter (Filter Query, see https://github.com/PDOK/locatieserver/wiki/Zoekvoorbeelden-Locatieserver) based on the checkboxes in the dialog. Defaults to []
        """
        
        self.fq_checkboxes = {
            LsType.gemeente,
            LsType.woonplaats,
            LsType.weg,
            LsType.postcode,
            LsType.adres,
            LsType.perceel,
            LsType.hectometerpaal,
        }
        filter = TypeFilter([])
        for key in self.fq_checkboxes:
            self.log(f"key is {key}")
            filter.add_type(key)
        return filter


    def toolbar_search_get_suggestions(self):
        self.log("Function toolbar_search_get_suggestions: starting")
        def create_model(_suggestions):
            model = QStandardItemModel()
            for s in _suggestions:
                key = s["weergavenaam"]
                it = QStandardItem(key)
                it.setData(s, Qt.ItemDataRole.UserRole)
                model.appendRow(it)
            return model

        search_text = self.dlg.zoomLineEdit.text()
        if len(search_text) <= 1:
            self.dlg.zoomLineEdit.setCompleter(None)
            return
        results = suggest_query(search_text, self.create_type_filter())
        self.completer = QCompleter()
        self.model = create_model(results)
        self.completer.setModel(self.model)
        self.completer.setCompletionMode(QCompleter.CompletionMode.PopupCompletion)
        self.completer.setFilterMode(Qt.MatchFlag.MatchContains)
        self.dlg.zoomLineEdit.setCompleter(self.completer)
        self.dlg.zoomLineEdit.show()
        self.completer.complete()
        self.completer.activated.connect(self.on_toolbar_suggest_activated)
        return


    def on_toolbar_suggest_activated(self, suggest_text):
        items = self.model.findItems(suggest_text)
        if len(items) == 0:  # check should not be necessary
            return
        item = items[0]
        data = item.data(Qt.ItemDataRole.UserRole)
        lookup_id = data["id"]
        self.lookup_toolbar_search_and_zoom(lookup_id)


    def lookup_toolbar_search_and_zoom(self, lookup_id):
        data = None
        try:
            data = lookup_object(lookup_id, Projection.EPSG_28992)
        except Exception as e:
            self.log(f"Failed to lookup an object in the search and zoom function. Error message: {e}")
        if data is None:
            return
        self.zoom_to_result(data)

    def zoom_to_result(self, data):
        # just always transform from 28992 to mapcanvas crs
        crs = self.iface.mapCanvas().mapSettings().destinationCrs()
        crs28992 = QgsCoordinateReferenceSystem.fromEpsgId(28992)
        crsTransform = QgsCoordinateTransform(crs28992, crs, QgsProject.instance())

        adrestekst = "{} - {}".format(data["type"], data["weergavenaam"])
        adrestekst_lower = adrestekst.lower()

        zoom_dict = {
            "adres": 794,
            "perceel": 794,
            "hectometer": 1587,
            "weg": 3175,
            "postcode": 6350,
            "woonplaats": 25398,
            "gemeente": 50797,
            "provincie": 812750,
        }
        z = 1587
        for z_type in zoom_dict.keys():
            if adrestekst_lower.startswith(
                z_type
            ):  # maybe find better way to infer return type?
                z = zoom_dict[z_type]

        geom = QgsGeometry.fromWkt(data["wkt_geom"])
        geom.transform(crsTransform)
        geom_type = geom.type()

        geom_type_dict = {
            QgsWkbTypes.PointGeometry: "point",
            QgsWkbTypes.LineGeometry: "linestring",
            QgsWkbTypes.PolygonGeometry: "polygon",
        }
        if geom_type not in geom_type_dict:
            self.info(
                f"unexpected geomtype return by ls: {geom_type}"
            )  # TODO: better error handling
            return

        geom_bbox = geom.boundingBox()
        rect = QgsRectangle(geom_bbox)
        rect.scale(1.2)
        self.iface.mapCanvas().zoomToFeatureExtent(rect)
        # for point features it is required to zoom to predefined zoomlevel depending on return type
        if re.match(r"^POINT", data["wkt_geom"]):
            self.iface.mapCanvas().zoomScale(z)
        self.iface.mapCanvas().refresh()



#########################################################################################
################################  General utility functions ########################
#########################################################################################


    def active_buttons(self, tabIndex):
        """Show or hide the load layers or themas buttons at the bottom"""
        if tabIndex == 1 or tabIndex == 2:
            self.dlg.load_button.show()
            self.dlg.load_close_button.show()
        else:
            self.dlg.load_button.hide()
            self.dlg.load_close_button.hide()


    def load_button_pressed(self, close):
        """Load the layers or thema when the button is pressed in the corresponding tab"""
        tab_index = self.dlg.tabWidget.currentIndex()
        
        if tab_index == 1:
            self.load_thema_layers()
        elif tab_index == 2:
            self.load_layer(None)

        if close:
            self.dlg.hide()


    def filter_layers(self, string):
        # remove selection if one row is selected
        self.log(f"Function filter_layers: input string is {string}")
        self.dlg.mapListView.selectRow(0)
        self.proxyModel.setFilterCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
        strlist = string.strip().split(" ")
        string = ""
        for s in strlist:
            string += f"{s}.*"
        regexp = QRegularExpression(string, QRegularExpression.PatternOption.CaseInsensitiveOption | QRegularExpression.PatternOption.InvertedGreedinessOption)
        self.log(f"The regexp to filter on is: {regexp}")
        self.proxyModel.setFilterRegularExpression(regexp)
        self.proxyModel.insertRow


    def log(self, text: str, lvl = 0):
        if not isinstance(text, str):
            text = str(text)
        
        log = QStandardItem(text)
        log.setToolTip(text)
        # print(text)
        QgsMessageLog.logMessage(text, PLUGIN_NAME, lvl)
        self.logModel.appendRow(
            [log]
        )


    # General add_action function to add action-buttons to the QGIS toolbar
    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action
    
    # General translation function (can probably be deleted)
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('NADMaps', message)